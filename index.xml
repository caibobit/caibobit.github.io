<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>窗外蟋蟀博客</title>
    <link>https://keysaim.github.io/</link>
    <description>Recent content on 窗外蟋蟀博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 21 Mar 2018 13:44:52 +0800</lastBuildDate>
    
        <atom:link href="https://keysaim.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://keysaim.github.io/about/</link>
      <pubDate>Wed, 21 Mar 2018 13:44:52 +0800</pubDate>
      
      <guid>https://keysaim.github.io/about/</guid>
      
        <description>&lt;p&gt;这是一个学习、分享的平台！&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>如何在github.io搭建Hugo博客站</title>
      <link>https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/</guid>
      
        <description>

&lt;h1 id=&#34;摘要&#34;&gt;摘要&lt;/h1&gt;

&lt;p&gt;在&lt;a href=&#34;Jekyll blog&#34;&gt;前面的博文&lt;/a&gt;中介绍了如何在&lt;code&gt;github.io&lt;/code&gt;上搭建自己的博客站，基于的是&lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt;，这也是github中比较常用的方式，好处是github可以自动调用&lt;code&gt;Jekyll&lt;/code&gt;来帮你及时生成、更新你的博客站。本来一切还是挺美好的，随着使用的深入，博主发现有几点实在是不能忍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;github上面的&lt;code&gt;Jekyll&lt;/code&gt;版本实在太低了，对于code block渲染问题严重。最受不了的一点就是很多种类型的code在里面被显示成一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Jekyll&lt;/code&gt;对文章的文件名有着严格的定义，且不能够放到不同的目录，这个在博文比较多的时候极为不便&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博主平时喜欢关注各种新技术，较早的时候就曾关注过一个的博客建站的工具&lt;code&gt;Hugo&lt;/code&gt;，用Go语言（博主的最爱之一）写的，当时就觉得挺不错。经过这几年的发展已经非常成熟，Github上面的Stars截止本文已经24250了。在经过一段时间的&lt;code&gt;Jekyll&lt;/code&gt;的折磨之后，终于乘着最近稍微闲了一点，将&lt;code&gt;Jekyll&lt;/code&gt;彻底换成了&lt;code&gt;Hugo&lt;/code&gt;。本文就简单介绍一下，如何在github.io上部署你的&lt;code&gt;Hugo&lt;/code&gt;博客站。&lt;/p&gt;

&lt;h1 id=&#34;准备工作&#34;&gt;准备工作&lt;/h1&gt;

&lt;p&gt;跟基于&lt;code&gt;Jekyll&lt;/code&gt;一样，如果需要在github.io上部署的话，必须在github上创建你自己的&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;的repo，详细过程请参见&lt;a href=&#34;Jekyll blog&#34;&gt;前面的博文&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;搭建-hugo-博客站&#34;&gt;搭建&lt;code&gt;Hugo&lt;/code&gt;博客站&lt;/h1&gt;

&lt;h2 id=&#34;安装-hugo&#34;&gt;安装&lt;code&gt;Hugo&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt;的安装非常简单，在MAC上执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```sh
brew install hugo
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它安装方式，可以参见&lt;a href=&#34;https://gohugo.io/getting-started/installing/&#34;&gt;官网教程&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;创建你的博客站&#34;&gt;创建你的博客站&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在github上面创建博客文章的repo&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt;的建站部署方式跟&lt;code&gt;Jekyll&lt;/code&gt;不同，github会自动的识别&lt;code&gt;Jekyll&lt;/code&gt;并调用&lt;code&gt;Jekyll&lt;/code&gt;工具帮你自动生成、更新博客站，所以我们只需要直接在自己的&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;中编写文章并上传即可。但是github并不能直接识别&lt;code&gt;Hugo&lt;/code&gt;的内容，因此，这个博客站的生成、更新的工作得由你自己完成，&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;只是用来托管你生成后的静态网站的内容（github支持托管静态网站，请参见&lt;a href=&#34;https://help.github.com/articles/user-organization-and-project-pages/#user--organization-pages&#34;&gt;这里&lt;/a&gt;)，因此，你还需要另一个git repo来真正的编辑、保存、管理你的博文。为此，博主创建了一个名为&lt;a href=&#34;https://github.com/keysaim/blogs&#34;&gt;blogs&lt;/a&gt;的repo，以下说到博文管理repo指的就是这个repo。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用&lt;code&gt;Hugo&lt;/code&gt;建站&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化博客站&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hugo new site blogs
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git init&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd blogs
git init
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指定github源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git remote add origin git@github.com:keysaim/blogs.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样，你本地的初始化的&lt;code&gt;Hugo&lt;/code&gt;博客站已经准备好了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加一个主题&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt;官方有非常多的免费开源的主题，&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;猛击这里&lt;/a&gt;。博主选用的是国人开发的一款主题&lt;a href=&#34;https://themes.gohugo.io/hugo-theme-jane/&#34;&gt;Jane&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule add -b master https://github.com/xianmin/hugo-theme-jane.git themes/jane
cp -r themes/jane/exampleSite/content ./
cp themes/jane/exampleSite/config.toml ./
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;本地测试&lt;/p&gt;

&lt;p&gt;在部署之前，先本地测试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后本地浏览器打开&lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt;，没有意外的话你将看到类似这样的：&lt;/p&gt;

&lt;div style=&#34;text-align:center&#34;&gt;
    &lt;img src=&#34;https://d33wubrfki0l68.cloudfront.net/9a581e943c0732d9c9852138ff0ad94f10b710a8/b6bf8/hugo-theme-jane/hugo-theme-jane/screenshot-hugo-theme-jane_huda38615ea8fd917fd31d36ba7a275d34_226834_1500x1000_fill_catmullrom_top_2.png&#34; alt=&#34;&#34; width=&#34;100%&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;这是&lt;code&gt;Jane&lt;/code&gt;主题默认提供的样式跟内容，说明你的本地&lt;code&gt;Hugo&lt;/code&gt;站可以正常工作了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;修改默认的配置&#34;&gt;修改默认的配置&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt;的默认配置文件是&lt;code&gt;config.toml&lt;/code&gt;，这里还是&lt;code&gt;Jane&lt;/code&gt;提供的默认配置，需要修改为你自己的信息，比如名字等，很多配置显而易见，这里不详述，只是着重指出几个有点困难或者比较重要的配置：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改&lt;code&gt;baseURL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;baseURL&lt;/code&gt;是你博客最终部署的网站的url，基于github.io的话就应该是这样的&lt;a href=&#34;https://keysaim.github.io/&#34;&gt;https://keysaim.github.io/&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启用gitment&lt;/p&gt;

&lt;p&gt;关于gitment的详细教程，请参见&lt;a href=&#34;https://keysaim.github.io/post/2017-08-16-how-to-add-comments/&#34;&gt;这篇博文&lt;/a&gt;，按照教程准备好github的几个token之后，只需要修改&lt;code&gt;Hugo&lt;/code&gt;配置中的这几行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[params.gitment]          # Gitment is a comment system based on GitHub issues. see https://github.com/imsun/gitment
    owner = &amp;quot;keysaim&amp;quot;              # Your GitHub ID
    repo = &amp;quot;comments&amp;quot;               # The repo to store comments
    clientId = &amp;quot;xxxx&amp;quot;           # Your client ID
    clientSecret = &amp;quot;xxxx&amp;quot;       # Your client secret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，repo就是教程中所说的github上面为保存comments而创建的repo，clientId跟clientSecret就是你自己创建的oauth授权信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改页面博文数量显示&lt;/p&gt;

&lt;p&gt;有几个参数会影响页面博文数的显示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;paginate = 15               # 首页每页显示的文章数
archive-paginate = 50       # 归档、标签、分类每页显示的文章数目
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改语言&lt;/p&gt;

&lt;p&gt;如果你需要将博客站显示成中文，那么请这么修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;defaultContentLanguage = &amp;quot;zh-cn&amp;quot;
[Languages.zh-cn]
  languageCode = &amp;quot;zh-cn&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;编辑博文&#34;&gt;编辑博文&lt;/h2&gt;

&lt;p&gt;默认情况下，&lt;code&gt;Jane&lt;/code&gt;主题将博文放在&lt;code&gt;content/post/&lt;/code&gt;下面，你需要在这下面编辑你的博文。&lt;code&gt;Hugo&lt;/code&gt;是支持分目录的，这点非常好，比如博主可以这么分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ll
total 4
drwxr-xr-x 3 nbaoping staff  102 Mar 21 16:22 arch
drwxr-xr-x 6 nbaoping staff  204 Mar 22 10:50 blog
drwxr-xr-x 5 nbaoping staff  170 Mar 22 10:33 docker
drwxr-xr-x 4 nbaoping staff  136 Mar 21 16:21 git
drwxr-xr-x 9 nbaoping staff  306 Mar 21 16:20 linux
drwxr-xr-x 3 nbaoping staff  102 Mar 21 16:22 note
drwxr-xr-x 3 nbaoping staff  102 Mar 21 16:24 others
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一点非常不错的就是&lt;code&gt;Hugo&lt;/code&gt;可以识别出&lt;code&gt;Jekyll&lt;/code&gt;的博文，包括里面的标题，时间跟标签等信息。这样博主非常方便的将之前的&lt;code&gt;Jekyll&lt;/code&gt;的所有博文直接迁移过来了，而无需做什么修改。当然，如果你新写博文的话，在博文的头部可以这样编写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
date: 2018-03-22
title: &amp;quot;如何在github.io搭建Hugo博客&amp;quot;
tags:
    - 教程
    - github
categories:
    - github
comment: true
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写完成之后，本地查看一下你的博文，没有问题的话先提交到你的博文管理的repo：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add xxxx
git commit -m &amp;quot;YOUR COMMIT MESSAGE&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;部署博客站&#34;&gt;部署博客站&lt;/h2&gt;

&lt;p&gt;这一步很关键了，咱们需要将自己的&lt;code&gt;Hugo&lt;/code&gt;博文站部署到github.io。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加你的github.io&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git submodule add -b master git@github.com:keysaim/keysaim.github.io.git public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里将其作为submodule添加进来，且放到&lt;code&gt;public&lt;/code&gt;目录下面，&lt;code&gt;public&lt;/code&gt;目录是&lt;code&gt;Hugo&lt;/code&gt;生成静态文件的地方，这样的话咱们就可以把生成出来的静态文件直接上传到你的&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;的repo里面了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成静态博客站&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接运行&lt;code&gt;hugo&lt;/code&gt;命令，就会在&lt;code&gt;public&lt;/code&gt;目录下生成静态博客站。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd public
git add .
git commit -m &amp;quot;YOUR COMMIT MESSAGE&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看你的github.io博客站&lt;/p&gt;

&lt;p&gt;正常情况下，过一会你就可以看到你基于&lt;code&gt;Hugo&lt;/code&gt;的github.io博客站了，博主的是&lt;a href=&#34;https://keysaim.github.io/&#34;&gt;https://keysaim.github.io/&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;自动部署脚本&#34;&gt;自动部署脚本&lt;/h2&gt;

&lt;p&gt;为了方便，&lt;code&gt;Hugo&lt;/code&gt;提供了一个&lt;a href=&#34;https://gohugo.io/hosting-and-deployment/hosting-on-github/#put-it-into-a-script&#34;&gt;自动部署的脚本&lt;/a&gt;，这里博主稍微修改了一点点用来同时提交这两个repo：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

if [ $# -lt  1 ]; then
    echo &amp;quot;$0 &amp;lt;commit message&amp;gt;&amp;quot;
    exit 1
fi

msg=&amp;quot;$1&amp;quot;
git commit -m &amp;quot;$msg&amp;quot;
if [ $? -ne 0 ]; then
    echo &amp;quot;Commit failed&amp;quot;
    exit 1
fi
git push origin master
if [ $? -ne 0 ]; then
    echo &amp;quot;Push failed&amp;quot;
fi

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build the project.
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add .

# Commit changes.
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back up to the Project Root
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，恭喜你已经完成了你的&lt;code&gt;Hugo&lt;/code&gt;博客站了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（五）常用命令</title>
      <link>https://keysaim.github.io/post/linux/2017-11-17-linux-study-common-tools/</link>
      <pubDate>Fri, 17 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-11-17-linux-study-common-tools/</guid>
      
        <description>

&lt;h1 id=&#34;cat命令&#34;&gt;cat命令&lt;/h1&gt;

&lt;p&gt;很多时候我们通过&lt;code&gt;cat&lt;/code&gt;命令来查看文件内容，它会将文件的所有内容显示出来。当然，&lt;code&gt;cat&lt;/code&gt;也可以通过管道接收数据，它主要完成的是将从管道接收的输入导到输出。&lt;/p&gt;

&lt;h1 id=&#34;more跟less命令&#34;&gt;more跟less命令&lt;/h1&gt;

&lt;p&gt;有时候用&lt;code&gt;cat&lt;/code&gt;命令来显示一个较大的文件并不方便，整个文件内容一次性显示出来简直就是刷屏了。如果需要一页页的显示内容，可以使用&lt;code&gt;more&lt;/code&gt;或者&lt;code&gt;less&lt;/code&gt;命令，这两个命令会以分页的形式显示文件内容，至于使用哪个命令完全看个人习惯了。此外，这两个命令不仅可以分页显示，而且在分页模式下，你可以用快捷键方便的浏览及搜索：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 按`d`下翻页
* 按空格下翻页
* 按回车下移一行
* 按`/`进入搜索模式，输入要搜索的关键字，按回车搜索。
* 按`n`搜索下一个
* 按`q`退出查看
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tee命令&#34;&gt;tee命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令一般从管道接收数据，这点与&lt;code&gt;cat&lt;/code&gt;类似，将stdin导到stdout。不同的是，&lt;code&gt;tee&lt;/code&gt;同时还可以指定一个文件作为输出。这点非常有用，有时候我们想一般看到命令的输出，同时又希望将输出保存到文件中，这时候用&lt;code&gt;tee&lt;/code&gt;最为合适。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date | tee time.log
Mon Nov 20 14:05:02 EST 2017
# cat time.log
Mon Nov 20 14:05:02 EST 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;date命令&#34;&gt;date命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;date&lt;/code&gt;命令用来显示时间跟时区，比较常见的用法有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认显示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date
Sun Nov 19 20:08:21 EST 2017
# date -u
Mon Nov 20 01:08:28 UTC 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;-u&lt;/code&gt;参数表示显示UTC标准时间，即时区为0的时间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指定显示格式&lt;/p&gt;

&lt;p&gt;除了默认输出，我们也可以指定显示的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date +&#39;%A %d-%m-%Y UTC %:z&#39;
Sunday 19-11-2017 UTC -05:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;date&lt;/code&gt;支持非常多元化的格式，具体可以参考&lt;a href=&#34;https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示当前时间的秒数&lt;/p&gt;

&lt;p&gt;通常，在计算当前时间的秒数的时候，我们通常会以&lt;a href=&#34;https://en.wikipedia.org/wiki/Unix_time&#34;&gt;Unix Epoch Time&lt;/a&gt;为基准，用&lt;code&gt;date&lt;/code&gt;命令可以非常方便的显示当前时间的秒数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date +%s
1511141040
# date +%s --date=&#39;2017/11/19 09:56:00&#39;
1511103360
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，也可以通过参数&lt;code&gt;--date&lt;/code&gt;指定时间来计算。反过来，如果我们知道了时间的秒数，需要显示其相对于Unix Epoch Time的时间，可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date; date +%s
Mon Nov 20 10:33:07 EST 2017
1511191987
# date --date=@1511191987
Mon Nov 20 10:33:07 EST 2017
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;时间偏移计算&lt;/p&gt;

&lt;p&gt;有时候需要知道多少天前是什么时间，这时候需要用到时间偏移计算了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date --date=&#39;100 seconds ago&#39;
Sun Nov 19 20:35:44 EST 2017
# date --date=&#39;100 hours ago&#39;
Wed Nov 15 16:37:28 EST 2017
# date --date=&#39;100 days ago&#39;
Fri Aug 11 21:37:34 EDT 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;date&lt;/code&gt;命令可以识别多种时间偏移写法，除了示例中的，还有&lt;code&gt;minutes months years&lt;/code&gt;等，当然，也可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date --date=&#39;+ 1000 seconds&#39;
Sun Nov 19 20:56:28 EST 2017
# date --date=&#39;- 1000 seconds&#39;
Sun Nov 19 20:23:41 EST 2017
# date --date=&#39;2017-11-19 00:00:00 + 1000 seconds&#39;
Sat Nov 18 09:00:01 EST 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接用&lt;code&gt;+&lt;/code&gt;或者&lt;code&gt;-&lt;/code&gt;表示以后或者以前的时间，也可以指定某个时间点然后偏移。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置时间&lt;/p&gt;

&lt;p&gt;当然，你也可以通过&lt;code&gt;date&lt;/code&gt;命令来设置时间：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date
Sun Nov 19 20:44:11 EST 2017
# date --set=&#39;Sun Nov 19 20:44:30 EST 2017&#39;
Sun Nov 19 20:44:30 EST 2017
# date
Sun Nov 19 20:44:31 EST 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;--set&lt;/code&gt;也可以简写为&lt;code&gt;-s&lt;/code&gt;，时间格式非常灵活：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date -s &#39;2017/11/20 10:19:50&#39;
Mon Nov 20 10:19:50 EST 2017
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;cal命令&#34;&gt;cal命令&lt;/h1&gt;

&lt;p&gt;我们用&lt;code&gt;date&lt;/code&gt;可以显示时间，同时咱们还可以通过&lt;code&gt;cal&lt;/code&gt;命令来显示日历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cal
    November 2017
Su Mo Tu We Th Fr Sa
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以指定要显示的日期，比如1949年10月的日历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cal 10 1949
    October 1949
Su Mo Tu We Th Fr Sa
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30 31
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;time命令&#34;&gt;time命令&lt;/h1&gt;

&lt;p&gt;有时候我们需要知道一个命令运行了多少时间，这时候我们可以用&lt;code&gt;time&lt;/code&gt;命令来计时：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# time sleep 1

real	0m1.018s
user	0m0.001s
sys  	0m0.002s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;sleep 1&lt;/code&gt;用来睡眠1秒，&lt;code&gt;real&lt;/code&gt;表示实际用了多少时间，&lt;code&gt;user&lt;/code&gt;表示在用户态花了多少时间，&lt;code&gt;sys&lt;/code&gt;则表示在内核花了多少时间。详细可以参考&lt;a href=&#34;https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1&#34;&gt;这篇问答&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;wc命令&#34;&gt;wc命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;wc&lt;/code&gt;命令是&lt;code&gt;Word Count&lt;/code&gt;的简称，顾名思义就是用来统计单词的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | wc -w
14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数&lt;code&gt;-w&lt;/code&gt;表示统计单词数，这里的单词实际上指的是被空格分开的字符串。下面列举出&lt;code&gt;wc&lt;/code&gt;命令的有关参数：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;统计多少单词&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;统计多少行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;统计有多少个字节&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;统计有多少个字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-L&lt;/td&gt;
&lt;td&gt;统计长度最长的行的长度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注意，这里的字节跟字符的差别，在英文中基本上是一样的，但是在多字节语言中，其意义就不一样了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &#39;你好&#39; | wc -c
7
# echo &#39;你好&#39; | wc -m
3
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;find命令&#34;&gt;find命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt;命令用来查找文件或目录，这又是一个非常强大的且常用的命令，这里只介绍几种常见的用法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据名字查找&lt;/p&gt;

&lt;p&gt;这是基本且常见的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# find . -name &amp;quot;test*&amp;quot;
./test.log
./test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例中表示在当前目录（用&lt;code&gt;.&lt;/code&gt;表示）下包括其子目录，查找文件名以&lt;code&gt;test&lt;/code&gt;开头的文件或者目录。默认情况下，&lt;code&gt;find&lt;/code&gt;命令是大小写敏感的，如果需要忽略大小写，则可以改用参数&lt;code&gt;-iname&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据路径查找&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-name&lt;/code&gt;参数会根据名字查找，如果需要对路径进行匹配查找，则可以用&lt;code&gt;-path&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# find . -path &amp;quot;./tmp/*&amp;quot;
./tmp/Test1
./tmp/test2
./tmp/test.log
./tmp/test.cpp
./tmp/time.log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据类型查找&lt;/p&gt;

&lt;p&gt;可以根据类型查找文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# find . -type f
./Test1
./test.log
./test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也可以同时根据类型跟文件名一起查找：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# find . -type f -name &amp;quot;test*&amp;quot;
./test.log
./test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;f&lt;/code&gt;表示文件，如果是查找目录的话则用&lt;code&gt;d&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据时间查找&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt;命令还可以根据时间来查找文件目录，其中一个用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find . -newer base_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示在当前目录下查找比&lt;code&gt;base_file&lt;/code&gt;文件更新的文件或者目录。此外，&lt;code&gt;find&lt;/code&gt;还可以根据文件的&lt;a href=&#34;https://www.unixtutorial.org/2008/04/atime-ctime-mtime-in-unix-filesystems/&#34;&gt;atime, ctime, mtime&lt;/a&gt;来查找文件，如下，根据修改时间来查找：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date
Fri Nov 17 20:34:52 EST 2017
# ll
total 20
drwxr-xr-x.  2 root root   45 Nov 17 02:46 ./
dr-xr-x---. 48 root root 8192 Nov 17 02:46 ../
-rw-r--r--.  1 root root    0 Nov 16 00:17 Test1
-rw-r--r--.  1 root root   34 Nov 17 02:46 test2
-rw-r--r--.  1 root root  102 Nov 17 00:30 test.log
# find . -mtime -1
.
./test.log
./test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-mtime&lt;/code&gt;表示根据修改时间查找，&lt;code&gt;-1&lt;/code&gt;表示最近一天。&lt;code&gt;find&lt;/code&gt;支持的时间查找总结如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-mtime&lt;/td&gt;
&lt;td&gt;根据修改时间，也就是&lt;code&gt;ls -l&lt;/code&gt;显示的时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-atime&lt;/td&gt;
&lt;td&gt;根据访问时间，也就是&lt;code&gt;ls -lu&lt;/code&gt;显示的时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-ctime&lt;/td&gt;
&lt;td&gt;根据状态改变的时间，也就是&lt;code&gt;ls -lc&lt;/code&gt;显示的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;时间值的表示说明：基准&lt;code&gt;+0&lt;/code&gt;表示一天前，&lt;code&gt;-1.5&lt;/code&gt;表示最近1.5天，&lt;code&gt;+1.5&lt;/code&gt;表示2.5天前&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逻辑查找&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt;支持与或非逻辑的查找，比如查找所有C++的源文件，实际上需要找出后缀为&lt;code&gt;.cpp&lt;/code&gt;跟&lt;code&gt;.h&lt;/code&gt;的文件，需要用到&lt;code&gt;find&lt;/code&gt;的逻辑或的查找：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find . -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-o&lt;/code&gt;是&lt;code&gt;-or&lt;/code&gt;的缩写，用来表示逻辑或的关系，而&lt;code&gt;-name &amp;quot;*.cpp&amp;quot;&lt;/code&gt;与&lt;code&gt;-name &amp;quot;*.h&amp;quot;&lt;/code&gt;为表达式，构成了&lt;code&gt;EXP1 or EXP2&lt;/code&gt;的关系，只要文件或者目录满足其中一个表达式就会输出。&lt;code&gt;find&lt;/code&gt;支持的逻辑关系如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;逻辑&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;与&lt;/td&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-and&lt;/code&gt;的缩写，逻辑与的关系，如&lt;code&gt;find . -type f -a -name &amp;quot;*.log&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;td&gt;-o&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-or&lt;/code&gt;的缩写，逻辑或的关系, 如&lt;code&gt;find . -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.h&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;非&lt;/td&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-not&lt;/code&gt;的缩写，逻辑非的关系, 如&lt;code&gt;find . ! -name &amp;quot;*.cpp&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，&lt;code&gt;find&lt;/code&gt;命令还有一个非常重要且常见的用法，就是在找到文件后执行某个命令，改用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -name &amp;quot;*.log&amp;quot; -exec rm {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示删除当前目录包括子目录中以&lt;code&gt;.log&lt;/code&gt;为后缀的所有文件。其中，&lt;code&gt;-exec&lt;/code&gt;表示在找到后需要执行命令，而命令为&lt;code&gt;rm {} \;&lt;/code&gt;，实际上此命令就是一般的&lt;code&gt;shell&lt;/code&gt;命令，其中&lt;code&gt;{}&lt;/code&gt;用来指代找到的文件或目录，这里&lt;code&gt;;&lt;/code&gt;必须转义，因为需要传递给&lt;code&gt;find&lt;/code&gt;本身，如果不转义，则会直接被&lt;code&gt;shell&lt;/code&gt;解析使用了。每找到一个文件或目录，都会执行指定的命令，其中&lt;code&gt;{}&lt;/code&gt;部分以文件路径替代。如果需要只执行一次命令，而把所有找到的文件作为参数传递给该命令，则需要用&lt;code&gt;+&lt;/code&gt;替代&lt;code&gt;\;&lt;/code&gt;，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -name &amp;quot;*.log&amp;quot; -exec rm {} +
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定找到的文件有&lt;code&gt;test.log&lt;/code&gt;，&lt;code&gt;test1.log&lt;/code&gt;，用&lt;code&gt;\;&lt;/code&gt;的方式相当于执行两次：&lt;code&gt;rm test.log&lt;/code&gt;跟&lt;code&gt;rm test1.log&lt;/code&gt;；如果使用&lt;code&gt;+&lt;/code&gt;则只有一次命令&lt;code&gt;rm test.log test1.log&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;sort命令&#34;&gt;sort命令&lt;/h1&gt;

&lt;p&gt;顾名思义，这个命令就是用来排序的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# head -n 5 /etc/passwd | sort
adm❌3:4:adm:/var/adm:/sbin/nologin
bin❌1:1:bin:/bin:/sbin/nologin
daemon❌2:2:daemon:/sbin:/sbin/nologin
lp❌4:7:lp:/var/spool/lpd:/sbin/nologin
root❌0:0:root:/root:/bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，&lt;code&gt;sort&lt;/code&gt;命令以字典顺序对每行进行排序，如果不带参数，会将整行作为一个字符串进行比较。当然，你也可以指定以第几列进行排序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# head -n 5 /etc/passwd | tr : &amp;quot; &amp;quot; | sort -k 3
root x 0 0 root /root /bin/bash
bin x 1 1 bin /bin /sbin/nologin
daemon x 2 2 daemon /sbin /sbin/nologin
adm x 3 4 adm /var/adm /sbin/nologin
lp x 4 7 lp /var/spool/lpd /sbin/nologin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里先将&lt;code&gt;:&lt;/code&gt;换成空格（关于&lt;code&gt;tr&lt;/code&gt;命令，请参照本文关于&lt;code&gt;tr&lt;/code&gt;命令的章节），然后以&lt;code&gt;-k&lt;/code&gt;为参数，指定以第三列进行排序。下面列举其常用的一些参数：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-k&lt;/td&gt;
&lt;td&gt;以第几列排序，列以空格为分隔&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;默认&lt;code&gt;sort&lt;/code&gt;以升序输出，&lt;code&gt;-r&lt;/code&gt;参数则可以以降序输出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;在指定第几列的时候，可以强制&lt;code&gt;sort&lt;/code&gt;把列的值以数字值进行排序，如下面的例子&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;默认情况下认为列是以空格为分隔，&lt;code&gt;-t&lt;/code&gt;参数则可以指定分隔符，这样，上面的例子其实可以直接写成&lt;code&gt;sort -t : -k 3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;忽略大小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;如果排序后出现重复的行，加上这个参数将只显示一行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test2
10
3
5
3
# cat test2 | sort
10
3
3
5
# cat test2 | sort -n
3
3
5
10
# cat test2 | sort -n -u
3
5
10
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;uniq命令&#34;&gt;uniq命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;uniq&lt;/code&gt;是&lt;code&gt;unique&lt;/code&gt;的简写，用来消除&lt;code&gt;sort&lt;/code&gt;排序后重复的行，即相当于&lt;code&gt;sort&lt;/code&gt;命令中的&lt;code&gt;-u&lt;/code&gt;参数。但是，&lt;code&gt;uniq&lt;/code&gt;不仅可以消除重复行，它还可以显示分别重复了多少行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test2 | sort -n | uniq -c
      2 3
      1 5
      1 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有些常用的参数如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;忽略大小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;只打印有重复的行，每组一个，如果要打印组内所有的，则用&lt;code&gt;-D&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;只打印没有重复的行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;比较的时候，忽略前面的N列&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;比较的时候，忽略前面的N个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;od命令&#34;&gt;od命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;od&lt;/code&gt;可以用来显示二进制文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test2
abcdefg
1234567
# od -t x1 test2
0000000 61 62 63 64 65 66 67 0a 31 32 33 34 35 36 37 0a
0000020
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也可以直接显示字符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# od -c test2
0000000   a   b   c   d   e   f   g  \n   1   2   3   4   5   6   7  \n
0000020
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，如果仅仅只是显示二进制内容，还可以使用&lt;code&gt;hexdump&lt;/code&gt;命令了。&lt;/p&gt;

&lt;h1 id=&#34;压缩类命令&#34;&gt;压缩类命令&lt;/h1&gt;

&lt;h2 id=&#34;tar命令&#34;&gt;tar命令&lt;/h2&gt;

&lt;p&gt;在Linux中，用的最多的压缩命令就是&lt;code&gt;tar&lt;/code&gt;命令了，在介绍其用法之前，需要清楚几个概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;存档文件(Archive File)&lt;/p&gt;

&lt;p&gt;存档文件用来打包多个文件成一个文件，以方便在网络上传输。请注意，打包成的文件并没有被压缩。在Linux或Unix系统中，TAR文件是最为常用的存档文件（通常以&lt;code&gt;.tar&lt;/code&gt;为文件后缀）。TAR文件的更多解释可以参考&lt;a href=&#34;http://www.bitzipper.com/tar-file.html&#34;&gt;这里&lt;/a&gt;。用&lt;code&gt;tar&lt;/code&gt;命令可以生产TAR文件，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar cvf tmp.tar tmp/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体参数在下面会具体解释，不带任何压缩格式的话，&lt;code&gt;tar&lt;/code&gt;命令会生成一个TAR文件。相应的，如果需要解开TAR文件，可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar xvf tmp.tar
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;压缩文件(Compressed File)&lt;/p&gt;

&lt;p&gt;TAR文件是没有被压缩的，大小基本保持不变。如果需要对文件进行压缩，则需要在&lt;code&gt;tar&lt;/code&gt;命令中加入压缩格式对应的参数，具体在下面会说明。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面来详细介绍&lt;code&gt;tar&lt;/code&gt;命令的用法，&lt;code&gt;tar&lt;/code&gt;的用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar --help
Usage: tar [OPTION...] [FILE]...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tar&lt;/code&gt;命令支持非常多的参数，这里列举比较常用的几种使用方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;压缩文件或目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar czvf tmp.tgz tmp/
tmp/
tmp/Test1
tmp/test.log
tmp/test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;czvf&lt;/code&gt;表示参数选项；&lt;code&gt;tmp.tgz&lt;/code&gt;表示压缩后的文件名，通常&lt;code&gt;tgz&lt;/code&gt;是&lt;code&gt;tar.gz&lt;/code&gt;的简写；&lt;code&gt;tmp/&lt;/code&gt;表示被压缩的目录。参数的解释如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Create&lt;/code&gt;的简写，表示生产压缩文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;z&lt;/td&gt;
&lt;td&gt;表示采用&lt;code&gt;gzip&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.tar.gz&lt;/code&gt;或者&lt;code&gt;.tgz&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;表示显示压缩的过程，会列出所有被压缩的文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;指定压缩文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;tar&lt;/code&gt;支持不同的压缩格式，除了&lt;code&gt;gzip&lt;/code&gt;之外，还有：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;j&lt;/td&gt;
&lt;td&gt;采用&lt;code&gt;bzip2&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.bz2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--lzip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;采用&lt;code&gt;lzip&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.lz&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--xz&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;采用&lt;code&gt;xz&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.xz&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--lzma&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;采用&lt;code&gt;lzma&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.lzma&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更多格式可以参考&lt;a href=&#34;http://www.gnu.org/software/tar/manual/html_node/gzip.html&#34;&gt;这里&lt;/a&gt;。当然，最为常用的两种格式为&lt;code&gt;gzip&lt;/code&gt;跟&lt;code&gt;bzip2&lt;/code&gt;，用法示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar czvf tmp.tgz tmp/
tar cjvf tmp.bz2 tmp/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;v&lt;/code&gt;参数可选，如果不需要显示压缩过程的话。需要注意的是，&lt;code&gt;tar&lt;/code&gt;压缩目录的时候会保持目录的结构。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解压文件&lt;/p&gt;

&lt;p&gt;对应于不同的压缩格式，解压参数稍微不一样，对于&lt;code&gt;gzip&lt;/code&gt;跟&lt;code&gt;bzip2&lt;/code&gt;分别示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar xzvf tmp.tgz
tar xjvf tmp.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与压缩不同，&lt;code&gt;c&lt;/code&gt;换成&lt;code&gt;x&lt;/code&gt;表示解压，其它参数含义与压缩一样。默认情况下，解压的文件会放在当前目录，如果需要解压到某个目录下，则可以用&lt;code&gt;-C&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar xzvf -C /tmp/ tmp.tgz
tar xjvf -C /tmp/ tmp.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列出压缩包里面的文件&lt;/p&gt;

&lt;p&gt;有时候我们需要先看看压缩包里面有哪些文件，但又并不想解压文件，可以采用&lt;code&gt;-t&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar czf tmp.tgz tmp/
# tar tvf tmp.tgz
drwxr-xr-x root/root         0 2017-11-17 02:46 tmp/
-rw-r--r-- root/root         0 2017-11-16 00:17 tmp/Test1
-rw-r--r-- root/root       102 2017-11-17 00:30 tmp/test.log
-rw-r--r-- root/root        34 2017-11-17 02:46 tmp/test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;tvf&lt;/code&gt;会列出压缩包中的文件，不论采用何种压缩格式，甚至是没有被压缩的TAR文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从压缩包中提取特定的文件&lt;/p&gt;

&lt;p&gt;在列出压缩包里面的内容后，如果只想提取里面的某些文件，可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar xzvf tmp.tgz tmp/test.log tmp/test2
tmp/test.log
tmp/test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，根据不同的压缩格式请替换成不同的参数。请务必注意，指定的文件必须是完整的路径，而不能只是文件名。&lt;/p&gt;

&lt;p&gt;另外，如果想提取一组匹配某种条件的文件，可以使用&lt;code&gt;--wildcards&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar xzvf tmp.tgz --wildcards &amp;quot;*.log&amp;quot;
tmp/test.log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;split命令&#34;&gt;split命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;split&lt;/code&gt;命令用来将一个文件分成多个文件，比如将一个特别大的文件分成平均大小为40M的多个文件等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# split -b 40M go1.6.linux-amd64.tar.gz go1.6.linux-amd64.tar.gz.part
# ll go1.6.linux-amd64.tar.gz.part*
-rw-r--r--. 1 root root 41943040 Nov 20 15:03 go1.6.linux-amd64.tar.gz.partaa
-rw-r--r--. 1 root root 41943040 Nov 20 15:03 go1.6.linux-amd64.tar.gz.partab
-rw-r--r--. 1 root root   913400 Nov 20 15:03 go1.6.linux-amd64.tar.gz.partac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;go1.6.linux-amd64.tar.gz&lt;/code&gt;是要被拆分的文件，&lt;code&gt;go1.6.linux-amd64.tar.gz.part&lt;/code&gt;是拆分后文件的前缀，可以看到文件被拆分为三部分了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;split&lt;/code&gt;非常常见的用法是来将某个被压缩的文件拆分成小的部分，正如上例所示。那么，如何将拆分的文件重新合并呢？我们可以用&lt;code&gt;cat&lt;/code&gt;将它们合并：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat go1.6.linux-amd64.tar.gz.part* &amp;gt; go1.6.linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;grep命令&#34;&gt;grep命令&lt;/h1&gt;

&lt;p&gt;过滤数据来说，用的最多的估计就是&lt;code&gt;grep&lt;/code&gt;命令了，&lt;code&gt;grep&lt;/code&gt;命令可以从文件或者管道中搜索数据并打印出来，当然，其也可以直接在目录中搜索所有的文件，并把其中符合条件的行打印出来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log | grep hello
hello
# grep hello test.log
hello
# grep hello . -r
./test.log:hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是三种方式搜索包括&lt;code&gt;hello&lt;/code&gt;关键字的行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;grep&lt;/code&gt;是Linux中使用最为频繁的命令之一，其本身也有非常强大的功能，这一节咱们将详细讲述其比较常见的用法。&lt;/p&gt;

&lt;h2 id=&#34;基本查找&#34;&gt;基本查找&lt;/h2&gt;

&lt;p&gt;查看&lt;code&gt;grep&lt;/code&gt;的帮助可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# grep --help
Usage: grep [OPTION]... PATTERN [FILE]...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;OPTION&lt;/code&gt;指的是命令参数，&lt;code&gt;PATTERN&lt;/code&gt;指的是匹配的字符串，比如关键字搜索。&lt;code&gt;FILE&lt;/code&gt;指的是文件，当然，没有文件的时候也可以通过管道接收数据并搜索过滤。&lt;code&gt;grep&lt;/code&gt;提供了非常多的命令参数用来控制查找的方式跟效果，下面列举其常用的一些参数：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;默认情况下，&lt;code&gt;grep&lt;/code&gt;命令的搜索是大小写敏感的，如果需要忽略大小写可以用这个参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;该参数表示不包含的意思&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-A2&lt;/td&gt;
&lt;td&gt;其中&lt;code&gt;A&lt;/code&gt;是&lt;code&gt;after&lt;/code&gt;的意思，表示同时显示搜索出来行后面两行。有时候我们需要知道匹配行后面是什么，可以用这个参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-B2&lt;/td&gt;
&lt;td&gt;与&lt;code&gt;A&lt;/code&gt;相反，其是&lt;code&gt;before&lt;/code&gt;的意思，表示同时显示匹配行前两行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-C2&lt;/td&gt;
&lt;td&gt;有时候我们想既显示前面两行也显示后面两行，这时候就用这个参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;搜索目录的时候需要带上这个参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;有些时候，我们需要知道匹配到的行是第几行，可以加上这个参数把行号打印出来&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对于&lt;code&gt;PATTERN&lt;/code&gt;，&lt;code&gt;grep&lt;/code&gt;命令也支持不同的用法：
* 关键字匹配&lt;/p&gt;

&lt;p&gt;这个是最常用的基本用法，匹配是否包括该关键字的行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正则匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了基本的关键字匹配，&lt;code&gt;grep&lt;/code&gt;还支持极为强大的正则表达式的匹配。我们将在下一小节专门讲述正则表达式匹配。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;或匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时候我们需要匹配某个PATTERN1或者PATTERN2的行，这时候可以这么写&lt;code&gt;PATTERN&lt;/code&gt;：&lt;code&gt;PATTERN1\|PATTERN2&lt;/code&gt;。通过&lt;code&gt;\|&lt;/code&gt;将多个&lt;code&gt;PATTERN&lt;/code&gt;连在一起表示或的意思，只要匹配其中任一个的行都会被打印出来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# grep &#39;12306\|test&#39; . -r
./test2:http://abcdefg.test.com
./test2:12306.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;正则表达式匹配&#34;&gt;正则表达式匹配&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;grep&lt;/code&gt;命令支持非常强大的正则匹配，支持三种不同的正则表达式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions&#34;&gt;ERE&lt;/a&gt;(POSIX-Extended Regular Expressions)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions&#34;&gt;BRE&lt;/a&gt;(POSIX_Basic_Regular_Expressions)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlre.html&#34;&gt;Perl Regular expression&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，比较常用的是&lt;code&gt;ERE&lt;/code&gt;正则表达式了。在&lt;code&gt;grep&lt;/code&gt;命令中，采用&lt;code&gt;-E&lt;/code&gt;参数即可以使用该表达式，正则表达式非常灵活，用法非常多，这里列举几个示例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;匹配以关键字开头的行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;grep -E &amp;quot;^keyword&amp;quot; . -r
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;匹配以关键字结尾的行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;grep -E &amp;quot;keyword$&amp;quot; . -r
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;匹配包含如&lt;code&gt;2017/10/11&lt;/code&gt;日期的行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;grep -E &amp;quot;[0-9]{4}/[0-9]{2}/[0-9]{2}&amp;quot; . -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意的是，对于数字的表示，其不支持如&lt;code&gt;\d&lt;/code&gt;这样的表达方式，而需要&lt;code&gt;[0-9]&lt;/code&gt;这样表达。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，如果需要熟练掌握&lt;code&gt;grep&lt;/code&gt;的正则表达式匹配，你必须对正则表达式非常熟悉，这个就不在本篇的范畴了。&lt;/p&gt;

&lt;h1 id=&#34;awk命令&#34;&gt;awk命令&lt;/h1&gt;

&lt;p&gt;要说Linux中最为强大的基本命令有哪些，那&lt;code&gt;awk&lt;/code&gt;无疑会榜上有名，其强大的流式处理能力，很多人甚至写书来专门讲这个命令。这里咱们暂时介绍基本的功能，以后有机会将专门开辟一文来展开。&lt;/p&gt;

&lt;p&gt;一个常见的用法就是把文件中的某几列打印出来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | awk &#39;{print $1, $2, $3}&#39;
Nov 17 00:27:20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上例，空格将一行分成了不同的列，咱们希望只把时间显示出来，而时间包括了第1，2，3列，因此，通过&lt;code&gt;awk &#39;{print $1, $2, $3}&#39;&lt;/code&gt;就实现了此功能，其中&lt;code&gt;$1&lt;/code&gt;就是引用第一列。&lt;/p&gt;

&lt;h1 id=&#34;cut命令&#34;&gt;cut命令&lt;/h1&gt;

&lt;p&gt;有时候，一行内的数据并不是通过空格分隔开的，而是通过其它分隔符，那如何显示想要的列呢？通过&lt;code&gt;cut&lt;/code&gt;命令，咱们同样可以轻松实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# head -n 5 /etc/passwd
root❌0:0:root:/root:/bin/bash
bin❌1:1:bin:/bin:/sbin/nologin
daemon❌2:2:daemon:/sbin:/sbin/nologin
adm❌3:4:adm:/var/adm:/sbin/nologin
lp❌4:7:lp:/var/spool/lpd:/sbin/nologin
# head -n 5 /etc/passwd | cut -d: -f1
root
bin
daemon
adm
lp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/passwd&lt;/code&gt;中的每一行基本上都是通过&lt;code&gt;:&lt;/code&gt;进行分隔，其中第一列表示用户名，如果咱们只想把用户名输出的话，可以通过&lt;code&gt;cut -d: -f1&lt;/code&gt;来实现，其中&lt;code&gt;-d:&lt;/code&gt;表示以&lt;code&gt;:&lt;/code&gt;号为分隔符，&lt;code&gt;-f1&lt;/code&gt;表示显示第一列。可见，对于&lt;code&gt;cut&lt;/code&gt;命令来说，咱们可以指定分隔符，那么前面通过&lt;code&gt;awk&lt;/code&gt;实现的例子也可以通过&lt;code&gt;cut&lt;/code&gt;来做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | cut -d&amp;quot; &amp;quot; -f1-3
Nov 17 00:27:20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-d&amp;quot; &amp;quot;&lt;/code&gt;表示以空格为分隔符（注意，这里的空格必须以引号括起来，不然会被shell展开去除多余空格），&lt;code&gt;-f1-3&lt;/code&gt;表示输出第1到3列，这里简用了&lt;code&gt;-&lt;/code&gt;来表示范围，当然也可以写成&lt;code&gt;-f1,2,3&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;此外，&lt;code&gt;cut&lt;/code&gt;命令还可以指定输出哪些位的字符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | cut -c1-16
Nov 17 00:27:20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;-c1-16&lt;/code&gt;表示输出第1到16个字符，当然，你同样可以以&lt;code&gt;,&lt;/code&gt;来分别列举要输出哪几个。&lt;/p&gt;

&lt;h1 id=&#34;tr命令&#34;&gt;tr命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;tr&lt;/code&gt;其实是&lt;code&gt;translate&lt;/code&gt;的缩写，这个命令用来将某些字符翻译成另外的字符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tr --help
Usage: tr [OPTION]... SET1 [SET2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令就是把字符集&lt;code&gt;SET1&lt;/code&gt;中的字符对应的转成字符集&lt;code&gt;SET2&lt;/code&gt;中的字符。如将小写转成大写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | tr a-z A-Z
NOV 17 00:27:20 TRAFFIC-BASE1 NAMED[1212]: MANAGED-KEYS-ZONE: UNABLE TO FETCH DNSKEY SET .: TIMED OUT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用&lt;code&gt;-&lt;/code&gt;来方便的表示一定范围的字符集，当然，你完全可以一个个列出来你要的字符集。通常情况下，&lt;code&gt;SET1&lt;/code&gt;跟&lt;code&gt;SET2&lt;/code&gt;的长度保持一致，因为这个转换实际上是一对一的转换，当然，&lt;code&gt;SET2&lt;/code&gt;的长度是可以大于&lt;code&gt;SET1&lt;/code&gt;的，多余的字符不会被使用。但是，当&lt;code&gt;SET2&lt;/code&gt;长度小于&lt;code&gt;SET1&lt;/code&gt;时，&lt;code&gt;tr&lt;/code&gt;命令会将&lt;code&gt;SET2&lt;/code&gt;中最后一个字符填充不足的位数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &#39;abcdefg&#39; | tr ab wyz
wycdefg
# echo &#39;abcdefg&#39; | tr abcdefg wyz
wyzzzzz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于&lt;code&gt;tr&lt;/code&gt;还有一个常见的用途，就是用来去除字符串中的换行符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# head -n 5 /etc/passwd
root❌0:0:root:/root:/bin/bash
bin❌1:1:bin:/bin:/sbin/nologin
daemon❌2:2:daemon:/sbin:/sbin/nologin
adm❌3:4:adm:/var/adm:/sbin/nologin
lp❌4:7:lp:/var/spool/lpd:/sbin/nologin
# head -n 5 /etc/passwd | tr &#39;\n&#39; &#39; &#39;
root❌0:0:root:/root:/bin/bash bin❌1:1:bin:/bin:/sbin/nologin daemon❌2:2:daemon:/sbin:/sbin/nologin adm❌3:4:adm:/var/adm:/sbin/nologin lp❌4:7:lp:/var/spool/lpd:/sbin/nologin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;\n&lt;/code&gt;表示换行符，示例中将换行符全部换成了空格。&lt;/p&gt;

&lt;p&gt;最后，&lt;code&gt;tr&lt;/code&gt;还有一个常见的用法，可以加上&lt;code&gt;-d&lt;/code&gt;参数来删除字符集中的字符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo abcdeWXYZ | tr -d a-z
WXYZ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例中删除了所有小写字母。&lt;/p&gt;

&lt;h1 id=&#34;sed命令&#34;&gt;sed命令&lt;/h1&gt;

&lt;p&gt;流式处理中，&lt;code&gt;sed&lt;/code&gt;也是一个极为常用的命令，它可以用来替换字串，比之前的&lt;code&gt;tr&lt;/code&gt;那是要强大无数倍了。&lt;/p&gt;

&lt;p&gt;查看&lt;code&gt;sed&lt;/code&gt;的帮助：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# sed --help
Usage: sed [OPTION]... {script-only-if-no-other-script} [input-file]...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它既可以直接在文件中替换字符串，也可以加收管道的数据。如基本用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo abcdefgabcd | sed &#39;s/abc/ABC/&#39;
ABCdefgabcd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;&#39;s/abc/ABC/&#39;&lt;/code&gt;指定了替换的规则，默认情况下只替换一次，如果需要全部替换，则需要在规则后面加入&lt;code&gt;g&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo abcdefgabcd | sed &#39;s/abc/ABC/g&#39;
ABCdefgABCd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;规则中默认使用了&lt;code&gt;/&lt;/code&gt;为分隔。当然，你也可以使用其他分隔符，这在要替换的字串中带有&lt;code&gt;/&lt;/code&gt;的时候特别有用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &amp;quot;http://abc.test.com&amp;quot; | sed &#39;s/http:\/\//https:\/\//&#39;
https://abc.test.com
# echo &amp;quot;http://abc.test.com&amp;quot; | sed &#39;s|http://|https://|&#39;
https://abc.test.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不指定新的分隔符&lt;code&gt;|&lt;/code&gt;，那么就得使用转义符&lt;code&gt;\&lt;/code&gt;将&lt;code&gt;//&lt;/code&gt;进行转义了，这样可读性就差了很多，采用&lt;code&gt;|&lt;/code&gt;就自然多了。&lt;code&gt;sed&lt;/code&gt;支持的分隔符还包括了&lt;code&gt;:&lt;/code&gt;，&lt;code&gt;_&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此外，&lt;code&gt;sed&lt;/code&gt;不仅可以用来替换字串，还可以用来删除匹配的行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test2
http://abcdefg.test.com
12306.com
# cat test2 | sed &#39;/12306/d&#39;
http://abcdefg.test.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;高级用法&#34;&gt;高级用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;后向引用（Back Referencing）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sed&lt;/code&gt;规则匹配到的字符串还可以在规则定义中被引用，如下例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &amp;quot;hello world&amp;quot; | sed &#39;s/hello/&amp;amp;&amp;amp;/&#39;
hellohello world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;&amp;amp;&lt;/code&gt;可以用来引用被匹配到的字串，在本例中，匹配到的字串是&lt;code&gt;hello&lt;/code&gt;，这样通过&lt;code&gt;&amp;amp;&lt;/code&gt;就可以引用被匹配到的字串了。此外，我们还可以通过&lt;code&gt;()&lt;/code&gt;来指定匹配的字串，并用&lt;code&gt;\1&lt;/code&gt;（数字表示第一个&lt;code&gt;()&lt;/code&gt;）来引用（实际上是正则表达式中的Grouping）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo Sunday | sed &#39;s/\(Sun\)/\1ny/&#39;
Sunnyday
# echo Sunday | sed &#39;s/\(Sun\)/\1ny \1/&#39;
Sunny Sunday
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;正则匹配&lt;/p&gt;

&lt;p&gt;由上述可以看出，&lt;code&gt;sed&lt;/code&gt;的规则使用了正则表达式规则，但是其书写跟一般的正则书写不一样，你必须将有关的字符转义，否则&lt;code&gt;sed&lt;/code&gt;仍然会将其当做普通字符进行匹配：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &amp;quot;this is aaaa cat&amp;quot; | sed &#39;s/a{4}/a/&#39;
this is aaaa cat
# echo &amp;quot;this is aaaa cat&amp;quot; | sed &#39;s/a\{4\}/a/&#39;
this is a cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，在没有转义&lt;code&gt;{&lt;/code&gt;及&lt;code&gt;}&lt;/code&gt;之前，&lt;code&gt;sed&lt;/code&gt;并没有匹配到目标字串&lt;code&gt;aaaa&lt;/code&gt;，而将其转义之后，则以正则表达式&lt;code&gt;a{4}&lt;/code&gt;匹配到了&lt;code&gt;aaaa&lt;/code&gt;并进行了替换。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;递归替换&lt;/p&gt;

&lt;p&gt;有时候我们需要在项目目录下替换某个字串，比如把手误写错的&lt;code&gt;#include&amp;lt;stdllib.h&amp;gt;&lt;/code&gt;全部替换成&lt;code&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;，希望被替换的文件包括&lt;code&gt;*.cpp&lt;/code&gt;，&lt;code&gt;*.h&lt;/code&gt;的文件。其中的一种做法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ head -n 1 test.cpp
#include &amp;lt;stdllib.h&amp;gt;
$ sed -i &#39;s/#include &amp;lt;stdllib.h&amp;gt;/#include &amp;lt;stdlib.h&amp;gt;/&#39; `find . -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.h&amp;quot;`
$ head -n 1 test.cpp
#include &amp;lt;stdlib.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用到了shell嵌入的用法（可以参看&lt;a href=&#34;https://keysaim.github.io/2017/10/10/linux-study-shell-basic/#shell嵌入与shell选项&#34;&gt;这一篇博文&lt;/a&gt;)，通过&lt;code&gt;find&lt;/code&gt;命令找出所有的源文件，然后用&lt;code&gt;sed -i&lt;/code&gt;进行替换，其中&lt;code&gt;-i&lt;/code&gt;表示从文件里面替换。这一用法会将&lt;code&gt;find&lt;/code&gt;找到的所有文件作为参数都追加到&lt;code&gt;sed&lt;/code&gt;命令后，在项目非常大的情况下可能会导致命令执行失败（因为数量庞大的文件导致追加的参数太大了），通常我们推荐采用&lt;code&gt;find&lt;/code&gt;的这种用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find . -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.h&amp;quot; -exec sed -i &#39;s/#include &amp;lt;stdllib.h&amp;gt;/#include &amp;lt;stdlib.h&amp;gt;/&#39; {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体可以参照本文中关于&lt;code&gt;find&lt;/code&gt;命令的介绍。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（四）IO重定向与管道</title>
      <link>https://keysaim.github.io/post/linux/2017-11-16-linux-study-io-pipe/</link>
      <pubDate>Thu, 16 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-11-16-linux-study-io-pipe/</guid>
      
        <description>

&lt;h1 id=&#34;io重定向-io-redirection&#34;&gt;IO重定向(IO redirection)&lt;/h1&gt;

&lt;p&gt;Linux的有一个强大之处就是可以通过管道(Pipe)跟IO重定向将一系列命令的输出跟输入连接起来。IO重定向是Linux中非常重要的概念，是理解Linux命令，脚本以及Linux IO的基础。&lt;/p&gt;

&lt;h2 id=&#34;标准输入输出&#34;&gt;标准输入输出&lt;/h2&gt;

&lt;p&gt;对于&lt;code&gt;shell&lt;/code&gt;来说，有三个基础的流，标准输入流(stdin或者stream 0)，标准输出流(stdout或者stream 1)，标准错误流(stderr或者stream2)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keysaim.github.io/img/blog-linux-shell-stdinout.png&#34; alt=&#34;标准输入输出&#34; /&gt;&lt;/p&gt;

&lt;p&gt;举个例子，当我们用键盘在&lt;code&gt;shell&lt;/code&gt;中执行命令的时候，可以如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keysaim.github.io/img/blog-linux-shell-keyboard-stdinout.png&#34; alt=&#34;键盘输入输出&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通常，stdout跟stderr都输出到了屏幕上，但对于Linux来说，其实是两种不同的输出。&lt;/p&gt;

&lt;h2 id=&#34;输出重定向&#34;&gt;输出重定向&lt;/h2&gt;

&lt;p&gt;可以用&lt;code&gt;&amp;gt;&lt;/code&gt;大于号将stdout重定向到另一个IO，比如文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo &amp;quot;hello&amp;quot; &amp;gt; test.log
# cat test.log
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令将stdout重定向到文件&lt;code&gt;test.log&lt;/code&gt;中，此时，如果该文件不存在则创建新文件，如果存在则覆盖已有文件。事实上，&lt;code&gt;&amp;gt;&lt;/code&gt;重定向是&lt;code&gt;1&amp;gt;&lt;/code&gt;的简写，&lt;code&gt;1&amp;gt;&lt;/code&gt;可以更清楚的看到实际上是把stdout(stream 1)重定向。&lt;/p&gt;

&lt;p&gt;必须注意的是，默认情况下，该重定向会覆盖已有文件，这个在有时候可能不经意间丢失重要数据。&lt;code&gt;shell&lt;/code&gt;提供了选项使得我们可以禁止这种覆盖，&lt;code&gt;set -o noclobber&lt;/code&gt;可以打开该选项。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat test.log
hello
# set -o noclobber
# echo &amp;quot;world&amp;quot; &amp;gt; test.log
-bash: test.log: cannot overwrite existing file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，在打开该选项之后，其实还是可以强制执行覆盖，可以采用&lt;code&gt;&amp;gt;|&lt;/code&gt;来强制重定向到已存在的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo &amp;quot;world&amp;quot; &amp;gt; test.log
-bash: test.log: cannot overwrite existing file
# echo &amp;quot;world&amp;quot; &amp;gt;| test.log
# cat test.log
world
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;追加输出&#34;&gt;追加输出&lt;/h2&gt;

&lt;p&gt;可以采用&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;将输出重定向到文件并追加在文件结尾，这样就可以避免覆盖文件了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat test.log
world
# echo hello &amp;gt;&amp;gt; test.log
# cat test.log
world
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标准错误重定向&#34;&gt;标准错误重定向&lt;/h2&gt;

&lt;p&gt;如&lt;code&gt;1&amp;gt;&lt;/code&gt;一样，我们可以通过&lt;code&gt;2&amp;gt;&lt;/code&gt;将stderr重定向到文件，具体行为跟stdout类似。&lt;/p&gt;

&lt;h2 id=&#34;同时重定向stdout跟stderr&#34;&gt;同时重定向stdout跟stderr&lt;/h2&gt;

&lt;p&gt;我们可以在同一行命令中同时将stdout跟stderr重定向，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls test* tttt*
ls: cannot access tttt*: No such file or directory
test.log  test2
# ls test* tttt* &amp;gt; stdout.log 2&amp;gt; stderr.log
# cat stdout.log
test.log
test2
# cat stderr.log
ls: cannot access tttt*: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，stdout跟stderr被分别重定向到&lt;code&gt;stdout.log&lt;/code&gt;跟&lt;code&gt;stderr.log&lt;/code&gt;文件中了。&lt;/p&gt;

&lt;p&gt;此外，还有一个常见的用法是将stderr重定向到stdout，这样就可以将所有输出都定向在一起了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls test* tttt* &amp;gt; stdout.log
ls: cannot access tttt*: No such file or directory
# cat stdout.log
test.log
test2
# ls test* tttt* &amp;gt; stdout.log 2&amp;gt;&amp;amp;1
# cat stdout.log
ls: cannot access tttt*: No such file or directory
test.log
test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，通过&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;将stderr重定向给stdout，而stdout又重定向给文件&lt;code&gt;stdout.log&lt;/code&gt;，这样所有的输出都重定向到文件&lt;code&gt;stdout.log&lt;/code&gt;中了。另外，还可以通过&lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt;直接将stderr跟stdout合并：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -l test* tttt* &amp;amp;&amp;gt; stdout.log
# cat stdout.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
-rw-r--r--. 1 root root  0 Nov 16 00:17 test2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重定向顺序&#34;&gt;重定向顺序&lt;/h2&gt;

&lt;p&gt;将stderr重定向给stdout的时候，请务必注意其顺序，如上面的重定向如果写成这样，结果就完全不同了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls test* tttt* 2&amp;gt;&amp;amp;1 &amp;gt; stdout.log
ls: cannot access tttt*: No such file or directory
# cat stdout.log
test.log
test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，stderr其实并没有被重定向到文件&lt;code&gt;stdout.log&lt;/code&gt;中，可见顺序是非常重要的。那么，如果理解这种不同呢？咱们可以这么样来理解：
* 将&lt;code&gt;&amp;gt;&lt;/code&gt;看作是&lt;code&gt;shell&lt;/code&gt;中的赋值操作&lt;code&gt;=&lt;/code&gt;
* 将stdout跟stderr看作是变量，但对其引用采用&lt;code&gt;&amp;amp;&lt;/code&gt;，这样&lt;code&gt;&amp;amp;1&lt;/code&gt;表示对stdout变量的引用
* 假定stdout跟stderr变量的初始值是屏幕，将屏幕记为&lt;code&gt;/dev/tty&lt;/code&gt;
* &lt;code&gt;shell&lt;/code&gt;从左到有扫描解释命令，并对stdout跟stderr分别赋值
* 查看stdout跟stderr的最终值即可知道分别被重定向到哪里了&lt;/p&gt;

&lt;p&gt;还是以上面的例子来解释，&lt;code&gt;ls test* tttt* 2&amp;gt;&amp;amp;1 &amp;gt; stdout.log&lt;/code&gt;
* 命令开始前，stdout=/dev/tty, stderr=/dev/tty
* &lt;code&gt;shell&lt;/code&gt;从左到右扫描并重新赋值，首先&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;就相当于&lt;code&gt;stderr=$stdin&lt;/code&gt;，此时&lt;code&gt;stderr&lt;/code&gt;的值其实还是&lt;code&gt;/dev/tty&lt;/code&gt;
* &lt;code&gt;&amp;gt; stdout.log&lt;/code&gt;就相当于&lt;code&gt;stdout=stdout.log&lt;/code&gt;，此时stdout值为&lt;code&gt;stdout.log&lt;/code&gt;
* 最后，stdout值为&lt;code&gt;stdout.log&lt;/code&gt;，而stderr值仍然为&lt;code&gt;/dev/tty&lt;/code&gt;，所以只有stdout输出到文件&lt;code&gt;stdout.log&lt;/code&gt;中了&lt;/p&gt;

&lt;p&gt;基于这个原则，在讲述完管道之后咱们将展示如何把stdout跟stderr交换一下。&lt;/p&gt;

&lt;h2 id=&#34;输入重定向&#34;&gt;输入重定向&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;符号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;既然输出有重定向，那么输入是否也可以呢？答案是肯定的，可以采用&lt;code&gt;&amp;lt;&lt;/code&gt;将输入重定向，&lt;code&gt;&amp;lt;&lt;/code&gt;其实是&lt;code&gt;0&amp;lt;&lt;/code&gt;的简写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat stdout.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
-rw-r--r--. 1 root root  0 Nov 16 00:17 test2
# cat &amp;lt;stdout.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
-rw-r--r--. 1 root root  0 Nov 16 00:17 test2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;符号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，还可以&lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt;通过手动输入直到输入&lt;code&gt;EOF&lt;/code&gt;（或者Ctrl-D）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;符号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该符号可以直接将一个字符串重定向给输入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# base64 &amp;lt;&amp;lt;&amp;lt; hello
aGVsbG8K
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;base64&lt;/code&gt;命令参数只接受文件，通过这种方式就可以把字符串直接传给它。&lt;/p&gt;

&lt;h2 id=&#34;输入输出同时重定向&#34;&gt;输入输出同时重定向&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;是可以支持同时重定向输入跟输出的，以下方式都会被准确解析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat &amp;lt;test.log &amp;gt; stdout.log 2&amp;gt; stderr.log
# &amp;lt;test.log &amp;gt; stdout.log 2&amp;gt; stderr.log cat
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;快速清除文件内容&#34;&gt;快速清除文件内容&lt;/h2&gt;

&lt;p&gt;可以通过重定向快速的清空文件内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat test.log
hello world
# &amp;gt; test.log
# cat test.log
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，咱们并不需要写&lt;code&gt;echo &amp;quot;&amp;quot; &amp;gt; test.log&lt;/code&gt;这样的命令来清空一个文件。当&lt;code&gt;noclobber&lt;/code&gt;选项被打开时，可以通过&lt;code&gt;&amp;gt;|&lt;/code&gt;来强制清空。&lt;/p&gt;

&lt;h1 id=&#34;管道-pipe&#34;&gt;管道(Pipe)&lt;/h1&gt;

&lt;p&gt;在Linux中，我们可以使用管道(Pipe)将前一个命令的stdout作为输入给后面一个命令，管道由&lt;code&gt;|&lt;/code&gt;表示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls test* tttt*
ls: cannot access tttt*: No such file or directory
test.log  test2
# ls -l test* tttt* | grep log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请务必注意的是，管道只会将stdout传递给下一个命令，stderr并不会传递，为了证明这一点，咱们将后一个命令的stderr重定向到文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -l test* tttt* | grep log 2&amp;gt; stderr.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
# cat stderr.log
# 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时可以看出，第二个命令的stderr为空，而第一个命令的stderr仍输出到屏幕了。当然，咱们也可以将第一个命令的stderr重定向到stdout上，这样&lt;code&gt;grep&lt;/code&gt;命令也可以收到了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -l test* tttt* 2&amp;gt;&amp;amp;1 | grep &amp;quot;No &amp;quot;
ls: cannot access tttt*: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再回到上一节的问题，咱们如何将stdout跟stderr互相交换一下呢？可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -l test* tttt* 3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3 | grep &amp;quot;No &amp;quot; 2&amp;gt; stderr.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
-rw-r--r--. 1 root root  0 Nov 16 00:17 test2
# cat stderr.log
# 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的Linux发行版本对grep输出的颜色设置正确，会发现只有第一行是grep出来的，由此可见&lt;code&gt;3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3&lt;/code&gt;居然将stdout跟stderr互换了一下，至于怎么解释，可以参照前面的赋值方式自行拆解一下。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>GPS管理系统服务器迁移指南</title>
      <link>https://keysaim.github.io/post/others/2017-10-11-rushgps-migrate/</link>
      <pubDate>Wed, 11 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/others/2017-10-11-rushgps-migrate/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;本指南主要讲述如何将GPS管理系统服务器迁移到另一台新的服务器，假定要迁移的服务器为server1，新服务器为server2，假定的服务器参数如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;服务器&lt;/th&gt;
&lt;th&gt;操作系统&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;外网地址&lt;/th&gt;
&lt;th&gt;外网开放端口&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;server1&lt;/td&gt;
&lt;td&gt;Centos 7&lt;/td&gt;
&lt;td&gt;10.10.10.100&lt;/td&gt;
&lt;td&gt;55.55.55.100&lt;/td&gt;
&lt;td&gt;9999, 9998&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;server2&lt;/td&gt;
&lt;td&gt;Centos 7&lt;/td&gt;
&lt;td&gt;10.10.10.101&lt;/td&gt;
&lt;td&gt;55.55.55.101&lt;/td&gt;
&lt;td&gt;9999, 9998&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;一下所有操作都以root权限进行，请务必注意&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;备份server1上的数据&#34;&gt;备份server1上的数据&lt;/h1&gt;

&lt;p&gt;请以ssh登陆到服务器，并切换到root用户。&lt;/p&gt;

&lt;h2 id=&#34;备份repo数据&#34;&gt;备份repo数据&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
cp -f /etc/yum.repos.d/mysql-community.repo /
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;备份数据库数据&#34;&gt;备份数据库数据&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
mysqldump -u root -p rushgps &amp;gt; rushgps.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入数据库密码完成备份，生成的备份文件为&lt;code&gt;rushgps.sql&lt;/code&gt;，其中数据库密码请联系维护人员索取，这里假定是&lt;code&gt;default&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;备份管理系统部署文件&#34;&gt;备份管理系统部署文件&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
tar czf root.tgz root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的备份文件为&lt;code&gt;root.tgz&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;备份管理系统资源文件&#34;&gt;备份管理系统资源文件&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
tar czf opt.tgz opt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的备份文件为&lt;code&gt;opt.tgz&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;备份supervisord配置&#34;&gt;备份supervisord配置&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cp -f /etc/supervisord.conf /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结，所有备份文件如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;备份文件&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/mysql-community.repo&lt;/td&gt;
&lt;td&gt;repo文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/rushgps.sql&lt;/td&gt;
&lt;td&gt;数据库备份文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/root.tgz&lt;/td&gt;
&lt;td&gt;部署文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/opt.tgz&lt;/td&gt;
&lt;td&gt;资源文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/supervisord.conf&lt;/td&gt;
&lt;td&gt;supervisord文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;安装server2操作系统&#34;&gt;安装server2操作系统&lt;/h1&gt;

&lt;p&gt;其中，server2操作系统安装过程这里不赘述，请确保是Centos 7系统，并配置好网络。&lt;/p&gt;

&lt;h1 id=&#34;迁移备份文件&#34;&gt;迁移备份文件&lt;/h1&gt;

&lt;p&gt;请将第一章中所有的备份文件上传到server2的目录&lt;code&gt;/&lt;/code&gt;下。&lt;/p&gt;

&lt;p&gt;请以ssh登陆到服务器，并切换到root用户。上传完成之后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
tar xzf root.tgz
tar xzf opt.tgz
cp -f /*.repo /etc/yum.repos.d/
cp -f /supervisord.conf /etc/
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;部署server2&#34;&gt;部署server2&lt;/h1&gt;

&lt;p&gt;部署过程中需要连接外网，请务必先配置好外网访问。&lt;/p&gt;

&lt;h2 id=&#34;安装mysql&#34;&gt;安装mysql&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装mysql软件&lt;/p&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yum -y install mysql-community-client mysql-community-devel mysql-community-server
systemctl enable mysqld
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初始化mysql&lt;/p&gt;

&lt;p&gt;安装完成之后需要初始化mysql的root用户密码，请执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl start mysqld
/usr/bin/mysqladmin -u root password &#39;default&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里假定密码是&lt;code&gt;default&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置数据库&#34;&gt;配置数据库&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建数据库&lt;/p&gt;

&lt;p&gt;GPS管理系统需要配置数据库，请执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入配置的密码后回车进入mysql的命令终端，然后再执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-terminal&#34;&gt;mysql&amp;gt; create database rushgps DEFAULT CHARACTER SET utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回车后完成初始化，按Ctrl+C退出。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;恢复数据库&lt;/p&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql -u root -p rushgps &amp;lt; /rushgps.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入配置的密码后回车，完成数据库恢复。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装gps系统依赖包&#34;&gt;安装GPS系统依赖包&lt;/h2&gt;

&lt;p&gt;同样，请务必确保外网访问。&lt;/p&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yum -y install python-devel zlib* gcc make supervisor
cd /root/ws/gpssys
pip install -r requirements.txt
systemctl enable supervisord
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置gps系统&#34;&gt;配置GPS系统&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建日志目录&lt;/p&gt;

&lt;p&gt;命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir -p /var/log/gpssys
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑GPS配置文件&lt;code&gt;/root/ws/gpssys/carerp/settings.py&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;找到&lt;code&gt;ALLOWED_HOSTS =&lt;/code&gt;这行，将server2的本地IP以及外网IP加入进去。&lt;/li&gt;
&lt;li&gt;找到&lt;code&gt;DATABASES =&lt;/code&gt;这行，往下找到&lt;code&gt;PASSWORD&lt;/code&gt;配置项，将它改成配置的mysql密码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动GPS系统&lt;/p&gt;

&lt;p&gt;执行一下命令启动：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl start supervisord
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，系统迁移完成，可以用浏览器打开系统&lt;code&gt;http://&amp;lt;server2 IP&amp;gt;:9999&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;系统维护篇&#34;&gt;系统维护篇&lt;/h1&gt;

&lt;h2 id=&#34;备份数据库&#34;&gt;备份数据库&lt;/h2&gt;

&lt;p&gt;请务必定期备份数据库，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;备份命令&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
mysqldump -u root -p rushgps &amp;gt; rushgps.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请将生成的备份文件&lt;code&gt;rushgps.sql&lt;/code&gt;拷贝到贵公司的保存数据的服务器上。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;恢复命令&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql -u root -p rushgps &amp;lt; rushgps.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重启gps系统&#34;&gt;重启GPS系统&lt;/h2&gt;

&lt;p&gt;如果碰到任何问题，请重启GPS系统：&lt;/p&gt;

&lt;p&gt;命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl restart supervisord
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（三）shell基础</title>
      <link>https://keysaim.github.io/post/linux/2017-10-10-linux-study-shell-basic/</link>
      <pubDate>Tue, 10 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-10-10-linux-study-shell-basic/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;首先，咱们来了解一下，什么是&lt;code&gt;Shell&lt;/code&gt;。操作系统内核给我们提供了各种接口，同时也提供了各种用户层的库，理论上我们基于这些可以编写程序实现各种我们想要的功能，不过问题是，咱们不可能做什么事情都要重新编写程序，这样使用起来也太困难了。因此，操作系统（包括Linux）通常都会引入一个&lt;code&gt;Shell&lt;/code&gt;这样的特殊程序，这个程序会接受输入的命令然后执行，并可能将执行结果呈现出来。总结来说，&lt;code&gt;Shell&lt;/code&gt;是一个从输入设备或者文件读取命令，并且解释、执行的用户态程序。&lt;/p&gt;

&lt;p&gt;在Linux系统中，通常使用的&lt;code&gt;Shell&lt;/code&gt;程序包括有：
* Sh (Bourne Shell)
* Bash (Bourne Again Shell)
* Csh (C Shell)
* Ksh (Korn Shell)&lt;/p&gt;

&lt;p&gt;一般来说，&lt;code&gt;Bash&lt;/code&gt;应该是使用最多的&lt;code&gt;Shell&lt;/code&gt;程序了，本文也主要基于&lt;code&gt;Bash&lt;/code&gt;来展开。&lt;/p&gt;

&lt;h1 id=&#34;shell展开-shell-expansion&#34;&gt;Shell展开（Shell Expansion）&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Shell&lt;/code&gt;程序是一个命令解释器，因此在终端输入命令之后，&lt;code&gt;Shell&lt;/code&gt;将扫描命令并做适当的修改，这个过程称为Shell展开。Shell展开是Shell解释执行之前极为重要的一步，了解它将有利于你对Shell命令或者脚本的理解，本章节将逐步带大家来了解这个过程。&lt;/p&gt;

&lt;h2 id=&#34;命令参数解析&#34;&gt;命令参数解析&lt;/h2&gt;

&lt;p&gt;这里的空格包括了制表符（Tab）。当Shell程序扫描输入的命令时，会以*连续*的空格为界，将命令切分成一组参数，因此你输入多个空格为界跟输入一个空格的效果是一样的。通常来讲，第一个参数就是要执行的命令，而后面的参数则是改命令的参数。一下几个命令其实是等效的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo Hello World
Hello World
# echo   Hello World
Hello World
#    echo Hello World
Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引号&#34;&gt;引号&lt;/h2&gt;

&lt;p&gt;当然，有时候你需要在一个参数中包括空格，这样的话你就需要将这个参数以引号引起来，引号包括了单引号&lt;code&gt;&#39;&lt;/code&gt;跟双引号&lt;code&gt;&amp;quot;&lt;/code&gt;，两者都可以。&lt;code&gt;shell&lt;/code&gt;会将引号中的字符串视为一个参数，不论里面有没有空格。当然，特别指出的是，不要用反引号&lt;code&gt;`&lt;/code&gt;，反引号将在后面详细讲述。&lt;/p&gt;

&lt;p&gt;如命令&lt;code&gt;echo &#39;Hello World!&#39;&lt;/code&gt;在&lt;code&gt;shell&lt;/code&gt;解析之后会有两个参数，分别为&lt;code&gt;echo&lt;/code&gt;跟&lt;code&gt;Hello World!&lt;/code&gt;。而如果不用引号&lt;code&gt;echo Hello World!&lt;/code&gt;，则将解析为三个参数。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;特别提一下，对于&lt;code&gt;echo&lt;/code&gt;命令，如果需要输出需要转义的字符，如回车等，则需要执行&lt;code&gt;echo -e &amp;quot;Hello World!\n&amp;quot;&lt;/code&gt;，如果不加&lt;code&gt;-e&lt;/code&gt;，则&lt;code&gt;\n&lt;/code&gt;会被直接显示出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;    # echo &amp;quot;hello\n&amp;quot;
&amp;gt;    hello\n
&amp;gt;    # echo -e &amp;quot;hello\n&amp;quot;
&amp;gt;    hello
&amp;gt;
&amp;gt;    ```

## 命令

对于`shell`来说，命令有内部命令（Builtin Commands）跟外部命令（External Commands）之分，所谓内部命令指的是包含在`shell`解析器中的命令。内部命令一般有[4种类型](http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands)：

* `sh`内部命令

    这些内部命令来源于`Bourne Shell`，通常包括了以下命令：
    `: . break cd continue eval exec exit export getopts hash pwd readonly return shift test/[ times trap umask unset`。

* `bash`内部命令

    这些内部命令来源于`Bourne Again Shell`，通常包括了以下命令：
    `alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias`。

* 修改`shell`行为的内部命令

    这些内部命令用来修改`shell`的默认行为。包括了`set shopt`命令。

* 特殊内部命令

    由于历史原因，POSIX标准将一些内部命令划分为特殊内部命令，特殊的之处在于这些命令的查找时间以及命令运行后的状态等方面，只有当Bash以[POSIX模式](http://www.gnu.org/software/bash/manual/bashref.html#Bash-POSIX-Mode)运行时，这些命令才是特殊命令，否则它们跟其它内部命令没啥区别。特殊内部命令包括了`break : . continue eval exec exit export readonly return set shift trap unset`。

**内部命令可能会被提前至于内存中，因此运行起来会比外部命令要快。**对于外部命令，可以认为除了内部命令之后就可以认为是外部命令了，通常来讲，`/bin`跟`/sbin`下的都是外部命令，当然，应用有关的通常也是外部命令。

我们可以通过`type`命令来查看一个命令是否是内部命令：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;type-cd&#34;&gt;type cd&lt;/h1&gt;

&lt;p&gt;cd is a shell builtin&lt;/p&gt;

&lt;h1 id=&#34;type-awk&#34;&gt;type awk&lt;/h1&gt;

&lt;p&gt;awk is /usr/bin/awk&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
另外，对于很多内部命令，它们可能对应的会有外部命令版本，可以通过`type`命令来查看：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;type-a-echo&#34;&gt;type -a echo&lt;/h1&gt;

&lt;p&gt;echo is a shell builtin
echo is /usr/bin/echo&lt;/p&gt;

&lt;h1 id=&#34;type-a-cd&#34;&gt;type -a cd&lt;/h1&gt;

&lt;p&gt;cd is a shell builtin
cd is /usr/bin/cd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
反过来，我们一般可以通过命令`which`来查询一个命令是否是外部命令：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;which-awk&#34;&gt;which awk&lt;/h1&gt;

&lt;p&gt;/usr/bin/awk&lt;/p&gt;

&lt;h1 id=&#34;which&#34;&gt;which .&lt;/h1&gt;

&lt;p&gt;/usr/bin/which: no . in (/opt/rh/rh-python34/root/usr/bin:/usr/java/default/bin/:/usr/local/git/bin:/opt/ActiveTcl-8.5/bin:/root/perl5/bin:/root/env/maven/apache-maven-3.3.3/bin:/root/soft/wrk/wrk-4.0.1:/root/usr/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
总结一下，通过`which`查询出来的是其外部命令版本，通过`type`默认查询出来的是内部命令：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;which-echo&#34;&gt;which echo&lt;/h1&gt;

&lt;p&gt;/usr/bin/echo&lt;/p&gt;

&lt;h1 id=&#34;type-echo&#34;&gt;type echo&lt;/h1&gt;

&lt;p&gt;echo is a shell builtin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
对于内部命令的详细说明，可以查看[GNU的文档](http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands)。

## 别名

可以用`alias`命令给一个命令取一个别名：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;alias-print-echo&#34;&gt;alias print=echo&lt;/h1&gt;

&lt;h1 id=&#34;print-hello&#34;&gt;print &amp;ldquo;hello&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;hello&lt;/p&gt;

&lt;h1 id=&#34;type-print&#34;&gt;type print&lt;/h1&gt;

&lt;p&gt;print is aliased to `echo&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
别名一个常用的用法是用来缩写已知的命令：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;type-ls&#34;&gt;type ls&lt;/h1&gt;

&lt;p&gt;ls is aliased to `ls &amp;ndash;color=auto&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
可见`ls`命令实际上是命令`ls --color=auto`的别名，这样就相当于改变了`ls`命令的默认行为了。在这种情况下，如果仍然想用原先的命令，可以在别名前加反斜杠`` \ ``：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;type-ls-1&#34;&gt;type ls&lt;/h1&gt;

&lt;p&gt;ls is aliased to `ls &amp;ndash;color=auto&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;ls&#34;&gt;\ls&lt;/h1&gt;

&lt;p&gt;Test1  test2  test.cpp  test.log  time.log&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

前面咱们通过`type`命令来查看命令的别名，实际上更加推荐采用`alias`或者`which`来查看：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;alias-ls&#34;&gt;alias ls&lt;/h1&gt;

&lt;p&gt;alias ls=&amp;lsquo;ls &amp;ndash;color=auto&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;which-ls&#34;&gt;which ls&lt;/h1&gt;

&lt;p&gt;alias ls=&amp;lsquo;ls &amp;ndash;color=auto&amp;rsquo;
    /usr/bin/ls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
如果要取消别名，则可以采用`unalias`命令:

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;which-ls-1&#34;&gt;which ls&lt;/h1&gt;

&lt;p&gt;alias ls=&amp;lsquo;ls &amp;ndash;color=auto&amp;rsquo;
    /usr/bin/ls&lt;/p&gt;

&lt;h1 id=&#34;unalias-ls&#34;&gt;unalias ls&lt;/h1&gt;

&lt;h1 id=&#34;which-ls-2&#34;&gt;which ls&lt;/h1&gt;

&lt;p&gt;/usr/bin/ls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

## 显示shell展开的结果

由于`shell`展开的存在，你输入的命令被展开之后可能会发生变化，如果需要知道`shell`展开之后的命令，可以使用内部命令`set`来修改`shell`的默认参数来显示：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;set-x&#34;&gt;set -x&lt;/h1&gt;

&lt;p&gt;++ printf &amp;lsquo;\033]0;%s@%s:%s\007&amp;rsquo; root traffic-base1 &amp;lsquo;~&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;echo-hello-world&#34;&gt;echo hello         world&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;echo hello world
hello world
++ printf &amp;lsquo;\033]0;%s@%s:%s\007&amp;rsquo; root traffic-base1 &amp;lsquo;~&amp;rsquo;
```&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，以&lt;code&gt;+&lt;/code&gt;开头的就是展开之后的命令，可见展开之后，&lt;code&gt;shell&lt;/code&gt;将多余的空格去掉了。如果不要再显示了，可以输入命令&lt;code&gt;set +x&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;shell控制操作符-control-operators&#34;&gt;shell控制操作符 (Control Operators）&lt;/h1&gt;

&lt;h2 id=&#34;操作符&#34;&gt;&lt;code&gt;$?&lt;/code&gt;操作符&lt;/h2&gt;

&lt;p&gt;每个命令执行完后都会有个退出码（Exit Code），其值为0时表示命令成功，否则命令失败。这个退出码可以通过&lt;code&gt;$?&lt;/code&gt;来访问，执行完命令后立马访问&lt;code&gt;$?&lt;/code&gt;可以获取该命令的退出码，并以此来判断命令是否成功。每个命令的执行都会产生新的退出码，所以请务必在命令执行完，立刻访问&lt;code&gt;$?&lt;/code&gt;来获取退出码。&lt;/p&gt;

&lt;p&gt;初看起来，&lt;code&gt;$?&lt;/code&gt;似乎是一个&lt;code&gt;shell&lt;/code&gt;变量，但实际上并非如此，因为你无法对&lt;code&gt;$?&lt;/code&gt;赋值。&lt;code&gt;$?&lt;/code&gt;准确来说是&lt;code&gt;shell&lt;/code&gt;的一个内部参数。&lt;/p&gt;

&lt;h2 id=&#34;分号&#34;&gt;分号&lt;code&gt;;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;命令输入时，你可以将多个命令输入在一行，只要在不同命令之间以分号&lt;code&gt;;&lt;/code&gt;隔开，当然分号不能是在引号中。
&amp;gt; 必须注意的是，如果将多个命令以&lt;code&gt;;&lt;/code&gt;连接在一起，执行的结果通过&lt;code&gt;$?&lt;/code&gt;查询出来将只是最后一个命令的结果&lt;/p&gt;

&lt;h2 id=&#34;符号&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;符号&lt;/h2&gt;

&lt;p&gt;通常情况下，&lt;code&gt;shell&lt;/code&gt;会在前台执行命令，并等待命令结束才返回。如果需要将命令放到后台去执行，可以使用&lt;code&gt;&amp;amp;&lt;/code&gt;符号放在命令最后面，这样的话命令会被放在后台执行，&lt;code&gt;shell&lt;/code&gt;会立刻返回而不用等待命令结束。
&amp;gt; 注意的是，即便放在后台执行，但是如果不处理好命令的输入，则命令的输出可能会继续在当前的终端输出，后面会讲述如何处理命令的输出。&lt;/p&gt;

&lt;h2 id=&#34;操作符-1&#34;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;操作符&lt;/h2&gt;

&lt;p&gt;此操作符表示逻辑与，你可以将两个命令用此操作符连接起来，如&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2&lt;/code&gt;，只有当&lt;code&gt;cmd1&lt;/code&gt;执行成功之后，&lt;code&gt;cmd2&lt;/code&gt;才会被执行。这里的成功指的是&lt;code&gt;cmd1&lt;/code&gt;的退出码是0。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# hello &amp;amp;&amp;amp; echo world
-bash: hello: command not found
# echo hello &amp;amp;&amp;amp; echo world
hello
world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;也可以将多个命令连接起来，其执行类似，只有当前面的命令成功，后面的才会执行。因此，将多个命令写在一行用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;可以实现，只不过&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;必须按照逻辑与的关系执行，而&lt;code&gt;;&lt;/code&gt;号的话会执行所有的命令。&lt;/p&gt;

&lt;h2 id=&#34;操作符-2&#34;&gt;&lt;code&gt;||&lt;/code&gt;操作符&lt;/h2&gt;

&lt;p&gt;很显然，与&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;相对，&lt;code&gt;||&lt;/code&gt;操作符表示逻辑或的关系，同样可以连接两个命令，如&lt;code&gt;cmd1 || cmd2&lt;/code&gt;，只有当&lt;code&gt;cmd1&lt;/code&gt;失败了，才会执行&lt;code&gt;cmd2&lt;/code&gt;，这里的失败指的是&lt;code&gt;cmd1&lt;/code&gt;的退出码非0。&lt;/p&gt;

&lt;h2 id=&#34;与-混合&#34;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;与&lt;code&gt;||&lt;/code&gt;混合&lt;/h2&gt;

&lt;p&gt;这两个操作符是可以混合使用的，其遵循的原则保持一致，且是从左向右依次判断，结合这两种操作符，可以实现类似于&lt;code&gt;if then else&lt;/code&gt;的逻辑结构。如&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2 || cmd3&lt;/code&gt;意思就是如果&lt;code&gt;cmd1&lt;/code&gt;成功，则执行&lt;code&gt;cmd2&lt;/code&gt;，否则执行&lt;code&gt;cmd3&lt;/code&gt;。但务必注意的是，此处并非真正意思上的&lt;code&gt;if then else&lt;/code&gt;逻辑，因为如果&lt;code&gt;cmd2&lt;/code&gt;也执行失败，&lt;code&gt;cmd3&lt;/code&gt;其实也会被执行。如下例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo hello &amp;amp;&amp;amp; echo ok || echo world
hello
ok
# echo hello &amp;amp;&amp;amp; rm dfsdf || echo world
hello
rm: cannot remove ‘dfsdf’: No such file or directory
world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;相当于将两条命令逻辑上连成了一条命令，这样就变成了&lt;code&gt;cmd1-2 || cmd3&lt;/code&gt;，其中&lt;code&gt;cmd1-2&lt;/code&gt;就是&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2&lt;/code&gt;，因此，&lt;code&gt;cmd3&lt;/code&gt;只要在&lt;code&gt;cmd1-2&lt;/code&gt;失败的情况下都会被执行，而&lt;code&gt;cmd1-2&lt;/code&gt;失败的情况有两种，一种是&lt;code&gt;cmd1&lt;/code&gt;失败，一种是&lt;code&gt;cmd1&lt;/code&gt;成功但是&lt;code&gt;cmd2&lt;/code&gt;失败。同样的，&lt;code&gt;||&lt;/code&gt;也会将两条命令连成一条命令，如&lt;code&gt;cmd1-2 || cmd3 &amp;amp;&amp;amp; cmd4&lt;/code&gt;就相当于&lt;code&gt;cmd1-2_3 &amp;amp;&amp;amp; cmd4&lt;/code&gt;，&lt;code&gt;cmd4&lt;/code&gt;是否会执行，决定于&lt;code&gt;cmd1-2_3&lt;/code&gt;是否失败，以具体例子说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo hello &amp;amp;&amp;amp; echo ok || echo world &amp;amp;&amp;amp; rm dsdfsf || echo end
hello
ok
rm: cannot remove ‘dsdfsf’: No such file or directory
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行命令相当于&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2 || cmd3 &amp;amp;&amp;amp; cmd4 || cmd5&lt;/code&gt;，可以看出&lt;code&gt;cmd1&lt;/code&gt;，&lt;code&gt;cmd2&lt;/code&gt;，&lt;code&gt;cmd4&lt;/code&gt;还是有&lt;code&gt;cmd5&lt;/code&gt;被执行了，而&lt;code&gt;cmd3&lt;/code&gt;没有执行。咱们来解析一下，为何是如此的执行结果。首先，&lt;code&gt;shell&lt;/code&gt;从左往右扫描执行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发现&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2&lt;/code&gt;，由&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;连成一个命令&lt;code&gt;cmd1-2&lt;/code&gt;，因为两个命令都是成功的，所以都被执行了，这样可以认为&lt;code&gt;cmd1-2&lt;/code&gt;成功&lt;/li&gt;
&lt;li&gt;执行成功之后，接下来是&lt;code&gt;||&lt;/code&gt;操作符，这里并不会因为前面的命令是成功的，而不再执行后面所有的命令，而是&lt;code&gt;||&lt;/code&gt;操作符相当于将&lt;code&gt;cmd1-2&lt;/code&gt;与&lt;code&gt;cmd3&lt;/code&gt;连接成了&lt;code&gt;cmd1-2_3&lt;/code&gt;，因为&lt;code&gt;cmd1-2&lt;/code&gt;成功了，所以&lt;code&gt;cmd3&lt;/code&gt;不再执行，但是&lt;code&gt;cmd1-2_3&lt;/code&gt;相当于执行成功了&lt;/li&gt;
&lt;li&gt;继续执行，发现是&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;操作符，同样将&lt;code&gt;cmd1-2_3&lt;/code&gt;与&lt;code&gt;cmd4&lt;/code&gt;连接起来，记为&lt;code&gt;cmd1-2_3-4&lt;/code&gt;，因为&lt;code&gt;cmd1-2_3&lt;/code&gt;执行成功了，所以&lt;code&gt;cmd4&lt;/code&gt;也被执行，但是&lt;code&gt;cmd4&lt;/code&gt;执行失败了，所以&lt;code&gt;cmd1-2_3-4&lt;/code&gt;相当于执行失败&lt;/li&gt;
&lt;li&gt;继续执行，发现是&lt;code&gt;||&lt;/code&gt;操作符，同样将&lt;code&gt;cmd1-2_3-4&lt;/code&gt;与&lt;code&gt;cmd5&lt;/code&gt;连成&lt;code&gt;cmd1-2_3-4_5&lt;/code&gt;，因为&lt;code&gt;cmd1-2_3-4&lt;/code&gt;执行失败，所以&lt;code&gt;cmd5&lt;/code&gt;被执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，&lt;code&gt;shell&lt;/code&gt;永远都是从左往右扫描执行，&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;跟&lt;code&gt;||&lt;/code&gt;会将前后两个命令连接起来，根据两种操作符的规则就可以知道多个连起来的命令是如何执行的了。&lt;/p&gt;

&lt;h2 id=&#34;符号-1&#34;&gt;&lt;code&gt;#&lt;/code&gt;符号&lt;/h2&gt;

&lt;p&gt;跟其它很多语言一样，&lt;code&gt;#&lt;/code&gt;在&lt;code&gt;shell&lt;/code&gt;里面用来注释。&lt;/p&gt;

&lt;h2 id=&#34;转义符号&#34;&gt;&lt;code&gt;\&lt;/code&gt;转义符号&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;\&lt;/code&gt;符号可以用来转义一些特殊符号，如&lt;code&gt;$&lt;/code&gt;，&lt;code&gt;#&lt;/code&gt;等。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;特别指出的是，如果转义符号放在行末单独使用，则用来连接下一行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;shell变量&#34;&gt;shell变量&lt;/h1&gt;

&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;

&lt;h3 id=&#34;定义跟引用&#34;&gt;定义跟引用&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;中也可以使用变量，变量不需要像其它语言一样需要预先申明。&lt;code&gt;shell&lt;/code&gt;中赋值给一个不存在的变量就相当于定义了变量，如&lt;code&gt;name=&amp;quot;Mr. Hao&amp;quot;&lt;/code&gt;，就定义了&lt;code&gt;name&lt;/code&gt;变量，后续如果再对&lt;code&gt;name&lt;/code&gt;赋值，就相当于改变改变量的值。与很多语言不同的是，&lt;code&gt;shell&lt;/code&gt;中变量引用以&lt;code&gt;$&lt;/code&gt;符号开头，后面跟变量的名字。如前面的变量，引用如下&lt;code&gt;echo &amp;quot;$name&amp;quot;&lt;/code&gt;。&lt;strong&gt;需要注意的是，在&lt;code&gt;shell&lt;/code&gt;中，变量名是大小写敏感的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;shell&lt;/code&gt;展开中会自动展开变量的引用，即便该变量处在双引号中。但是，如果变量引用在单引号中，&lt;code&gt;shell&lt;/code&gt;不会对其进行解析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# name=&amp;quot;Mr. Hao&amp;quot;
# echo &amp;quot;$name&amp;quot;
Mr. Hao
# set -x
# echo &#39;$name&#39;
+ echo &#39;Mr. Hao&#39;
$name
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查找变量&#34;&gt;查找变量&lt;/h3&gt;

&lt;p&gt;可以使用&lt;code&gt;set&lt;/code&gt;命令来查找所定义的变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# set | grep -E &#39;^name=&#39;
name=&#39;Mr. Hao&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;删除变量&#34;&gt;删除变量&lt;/h3&gt;

&lt;p&gt;与很多语言不同的是，在&lt;code&gt;shell&lt;/code&gt;中定义的变量是可以删除的，使用&lt;code&gt;unset&lt;/code&gt;命令删除定义的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# set | grep -E &#39;^name=&#39;
name=&#39;Mr. Hao&#39;
# unset name
# set | grep -E &#39;^name=&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;export-声明&#34;&gt;&lt;code&gt;export&lt;/code&gt;声明&lt;/h3&gt;

&lt;p&gt;通常情况下，&lt;code&gt;shell&lt;/code&gt;在执行命令的时候会为该命令创建子进程。如果希望将当前的变量作用到子进程，则需要将变量&lt;code&gt;export&lt;/code&gt;声明，这种变量称之为环境变量，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# var1=&amp;quot;hello&amp;quot;
# export var2=&amp;quot;world&amp;quot;
# bash
# echo &amp;quot;var1=$var1, var2=$var2&amp;quot;
var1=, var2=world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;bash&lt;/code&gt;命令开启了一个新的&lt;code&gt;shell&lt;/code&gt;，可见只有&lt;code&gt;export&lt;/code&gt;声明的变量在新的&lt;code&gt;shell&lt;/code&gt;中才是可见的。环境变量可以通过&lt;code&gt;env&lt;/code&gt;命令列举出来，在后面一节会详细讲述。此外，如果需要将非&lt;code&gt;export&lt;/code&gt;变量重新声明为&lt;code&gt;export&lt;/code&gt;变量，则只需要用&lt;code&gt;export&lt;/code&gt;重新声明一下即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# var1=hello
# env | grep var1
# export var1
# env | grep var1
var1=hello
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;env-命令&#34;&gt;&lt;code&gt;env&lt;/code&gt;命令&lt;/h3&gt;

&lt;p&gt;如果需要查看当前&lt;code&gt;shell&lt;/code&gt;中有哪些&lt;code&gt;export&lt;/code&gt;声明的变量，可以使用&lt;code&gt;env&lt;/code&gt;命令，该命令会列出当前所有&lt;code&gt;export&lt;/code&gt;声明的变量。请注意与&lt;code&gt;set&lt;/code&gt;命令的区别，&lt;code&gt;set&lt;/code&gt;命令会列出所有的变量，包括哪些不是&lt;code&gt;export&lt;/code&gt;声明的变量。通常，我们把&lt;code&gt;env&lt;/code&gt;命令输出的变量称之为&lt;code&gt;环境变量&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此外，&lt;code&gt;env&lt;/code&gt;也常用来为子&lt;code&gt;shell&lt;/code&gt;预先定义一些临时变量，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# var1=&amp;quot;hello&amp;quot;
# env var1=&amp;quot;tmp&amp;quot; bash -c &#39;echo &amp;quot;$var1&amp;quot;&#39;
tmp
# echo $var1
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，用&lt;code&gt;env&lt;/code&gt;命令定义了临时变量&lt;code&gt;var1&lt;/code&gt;，然后&lt;code&gt;bash&lt;/code&gt;命令开启了一个子&lt;code&gt;shell&lt;/code&gt;，并在子&lt;code&gt;shell&lt;/code&gt;中执行了&lt;code&gt;echo &amp;quot;$var1&amp;quot;&lt;/code&gt;命令。可见，输出了定义的临时变量，在命令结束后，又回到之前的&lt;code&gt;shell&lt;/code&gt;，输出的也是之前&lt;code&gt;shell&lt;/code&gt;中定义的值。当然，在使用&lt;code&gt;env&lt;/code&gt;定义临时变量的时候，为了方便，通常我们可以省略&lt;code&gt;env&lt;/code&gt;命令，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# var1=&amp;quot;hello&amp;quot;
# var1=&amp;quot;tmp&amp;quot; bash -c &#39;echo &amp;quot;$var1&amp;quot;&#39;
tmp
# echo $var1
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，&lt;code&gt;env&lt;/code&gt;命令还有一种常用的用法，就是用来开启一个干净的子&lt;code&gt;shell&lt;/code&gt;，即在子&lt;code&gt;shell&lt;/code&gt;中不继承所有的变量，即便这些变量在之前的&lt;code&gt;shell&lt;/code&gt;中采用&lt;code&gt;export&lt;/code&gt;声明，此时&lt;code&gt;env&lt;/code&gt;命令需要加入&lt;code&gt;-i&lt;/code&gt;的参数，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# export var1=&amp;quot;hello world&amp;quot;
# bash -c &#39;echo &amp;quot;var1=$var1&amp;quot;&#39;
var1=hello world
# env -i bash -c &#39;echo &amp;quot;var1=$var1&amp;quot;&#39;
var1=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，使用&lt;code&gt;env -i&lt;/code&gt;之后，即便&lt;code&gt;var1&lt;/code&gt;被&lt;code&gt;export&lt;/code&gt;声明，但是在子&lt;code&gt;shell&lt;/code&gt;中也没有被继承。&lt;/p&gt;

&lt;h3 id=&#34;变量解释&#34;&gt;变量解释&lt;/h3&gt;

&lt;p&gt;在前面章节，我们知道&lt;code&gt;shell&lt;/code&gt;采用&lt;code&gt;$&lt;/code&gt;符号引用变量，在&lt;code&gt;$&lt;/code&gt;符号后紧跟变量的名字。而&lt;code&gt;shell&lt;/code&gt;在提取变量名字的时候一般以非字母数字（non-alphanumeric）为边界，这有时候就会产生问题，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# prefix=Super
# echo Hello $prefixman and $prefixgirl
Hello  and
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，&lt;code&gt;shell&lt;/code&gt;并不能提取我们定义的变量&lt;code&gt;prefix&lt;/code&gt;，因为其后并没有非字母数字的字符为界。这种情况下，我们可以使用&lt;code&gt;{}&lt;/code&gt;将变量名保护起来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# prefix=Super
# echo Hello ${prefix}man and ${prefix}girl
Hello Superman and Supergirl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;非绑定-unbound-变量&#34;&gt;非绑定（unbound）变量&lt;/h3&gt;

&lt;p&gt;所谓非绑定（unbound）变量其实指的是没有预先定义的变量，或者说不存在的变量。默认情况下，&lt;code&gt;shell&lt;/code&gt;在解释这种变量的时候会以空字符串替代：&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1 id=&#34;echo-unbound-var&#34;&gt;echo $unbound_var&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
如果需要`shell`在这种情况下报错，可以配置`shell`选项`set -o nounset`，或者简写为`set -u`：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;echo-unbound-var-1&#34;&gt;echo $unbound_var&lt;/h1&gt;

&lt;p&gt;bash: unbound_var: unbound variable&lt;/p&gt;

&lt;h1 id=&#34;set-u&#34;&gt;set +u&lt;/h1&gt;

&lt;h1 id=&#34;echo-unbound-var-2&#34;&gt;echo $unbound_var&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;
当然，由例子中可以看到，要取消该配置，可以相应的设置`set +o nounset`，或者简写为`set +u`。

## 特殊变量

在`shell`中预定义了很多特殊的变量，这一节咱们来说一下常见的几个变量。

### `$PS1`变量

在`shell`终端输入命令时，咱们总是可以看到在输入行首总是会有提示符，如：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mrhao:~$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
其中，`mrhao:~$ `就是提示符，这个字串实际上是由`shell`变量`$PS1`决定的。如果咱们改变一下该变量的值，提示符也会相应的改变：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mrhao:~$ PS1=&amp;ldquo;hello &amp;gt; &amp;ldquo;
hello &amp;gt; echo &amp;ldquo;PS1 value is &amp;lsquo;$PS1&amp;rsquo;&amp;rdquo;
PS1 value is &amp;lsquo;hello &amp;gt; &amp;lsquo;
hello &amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
为了方便在提示符中显示系统的某些实时信息，`$PS1`变量定义了一些特殊的字符：

| 字符 | 说明               |
|------|--------------------|
| \w   | 表示工作目录       |
| \u   | 表示用户名         |
| \h   | 表示系统的hostname |

当然，这里只列举了几个，详细的可以查看Linux手册。另外，`$PS1`中还可以对对其中不同部分采用不同颜色显示，如：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;red-033-01-31m&#34;&gt;RED=&amp;rsquo;[\033[01;31m]&amp;lsquo;&lt;/h1&gt;

&lt;h1 id=&#34;white-033-01-00m&#34;&gt;WHITE=&amp;rsquo;[\033[01;00m]&amp;lsquo;&lt;/h1&gt;

&lt;h1 id=&#34;green-033-01-32m&#34;&gt;GREEN=&amp;rsquo;[\033[01;32m]&amp;lsquo;&lt;/h1&gt;

&lt;h1 id=&#34;blue-033-01-34m&#34;&gt;BLUE=&amp;rsquo;[\033[01;34m]&amp;lsquo;&lt;/h1&gt;

&lt;h1 id=&#34;ps1-green-u-white-blue-h-white-w&#34;&gt;PS1=&amp;ldquo;$GREEN\u$WHITE@$BLUE\h$WHITE\w\$ &amp;ldquo;&lt;/h1&gt;

&lt;p&gt;mrhao@mrhao-host~$ echo &amp;ldquo;$PS1&amp;rdquo;
[\033[01;32m]\u[\033[01;00m]@[\033[01;34m]\h[\033[01;00m]\w$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
### `$PATH`变量

当我们在Linux的terminal里面输入命令的时候，`shell`需要在一系列的目录中查找输入的命令，如果没有查找到会直接报`command not found`的错误。而这些查找的目录就定义在`$PATH`变量中。

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;echo-path&#34;&gt;echo $PATH&lt;/h1&gt;

&lt;p&gt;/opt/rh/rh-python34/root/usr/bin:/usr/java/default/bin/:/usr/local/git/bin:/opt/ActiveTcl-8.5/bin:/root/perl5/bin:/root/env/maven/apache-maven-3.3.3/bin:/root/soft/wrk/wrk-4.0.1:/root/usr/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
其中，每个目录以`:`隔开，如果需要增加目录，可以：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;path-path-opt-local-bin&#34;&gt;PATH=$PATH:/opt/local/bin&lt;/h1&gt;

&lt;h1 id=&#34;echo-path-1&#34;&gt;echo $PATH&lt;/h1&gt;

&lt;p&gt;/opt/rh/rh-python34/root/usr/bin:/usr/java/default/bin/:/usr/local/git/bin:/opt/ActiveTcl-8.5/bin:/root/perl5/bin:/root/env/maven/apache-maven-3.3.3/bin:/root/soft/wrk/wrk-4.0.1:/root/usr/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/opt/local/bin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;gt; 加入新的路径的时候请务必带上之前的路径，`$PATH:&amp;lt;new path&amp;gt;`否则，很多默认的系统路径将被覆盖，导致很多命令失效。

特别注意的是，`$PATH`变量中目录的顺序是很重要的，如果`shell`在前面的目录中找到了命令，则不会查找后面的目录。如果你想把某个重名的命令优先执行，就需要把它对应的目录放在`$PATH`的前面。

### 网络代理变量

在Linux系统中，很多时候我们需要访问外部网络，比如使用`curl`命令下载文件等等。而有的时候，访问访问外部网络咱们需要设置代理，在Linux系统中，使用网络代理非常简单，只要配置几个变量即可：

| 变量        | 说明                                                                    |
|-------------|-------------------------------------------------------------------------|
| http_proxy  | 设置访问`http`请求所需要的代理，如`http_proxy=http://10.10.10.100:80`   |
| https_proxy | 设置访问`https`请求所需要的代理，如`https_proxy=http://10.10.10.100:80` |
| ftp_proxy   | 设置访问`ftp`请求所需要的代理，如`ftp_proxy=http://10.10.10.100:80`     |
| no_proxy    | 设置哪些域名或者IP不需要走代理，如`no_proxy=localhost,127.0.0.1`        |

### `$PWD`变量

`PWD`变量是一个由`shell`自动设置的变量，其值表示当前目录的绝对路径，与命令`pwd`输出相同。

# `shell`嵌入与`shell`选项

## `shell`嵌入（shell embedding）

`shell`可以嵌入在同一个命令行中，也就是`shell`在扫描解释命令行的时候，可能会从当前的`shell`进程中`fork`出一个新的`shell`进程，并将有关命令放在新进程中运行。如下例：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;var1-hello&#34;&gt;var1=hello&lt;/h1&gt;

&lt;h1 id=&#34;echo-var1-world-echo-var1&#34;&gt;echo $(var1=world; echo $var1)&lt;/h1&gt;

&lt;p&gt;world&lt;/p&gt;

&lt;h1 id=&#34;echo-var1&#34;&gt;echo $var1&lt;/h1&gt;

&lt;p&gt;hello&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
如其中`$()`便开启了一个新的`shell`进程，或者成为子`shell`，并在此`shell`中运行命令`var1=world; echo $var1`，此时输出的是子`shell`中定义的`var1`。当命令结束后，子`shell`进程退出，并将输出的结果`world`返回给之前的`shell`（或者父`shell`）的`echo`命令，父`shell`最后输出`world`。而且，在子`shell`中定义相同的`var1`变量并不会改变父`shell`中的变量。

***特别注意的是，因为子`shell`是`fork`出来的进程，根据Linux进程`fork`的特点，子进程将共享父进程的数据空间，而只在写的时候拷贝新的数据空间，因此，创建出来的子`shell`是会继承所有父`shell`的变量，不论该变量是否被`export`声明***

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;var1-hello-1&#34;&gt;var1=hello&lt;/h1&gt;

&lt;h1 id=&#34;var2-echo-var1-world&#34;&gt;var2=&amp;ldquo;$(echo $var1 world)&amp;rdquo;&lt;/h1&gt;

&lt;h1 id=&#34;echo-var2&#34;&gt;echo $var2&lt;/h1&gt;

&lt;p&gt;hello world&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
可见，虽然`var1`变量没有`export`声明，但是在子`shell`中还是可见的。这点与使用`bash -c`开启的`shell`是不同的。

用`$()`可以将子`shell`嵌入到命令行中，当然，`$()`是可以嵌套使用的，这样可以用来在子`shell`中开启它的子`shell`。

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;a-shell&#34;&gt;A=shell&lt;/h1&gt;

&lt;h1 id=&#34;echo-c-b-a-b-sub-echo-c-b-a-echo-c-sub-echo-c-b-a&#34;&gt;echo $C$B$A $(B=sub;echo $C$B$A; echo $(C=sub;echo $C$B$A))&lt;/h1&gt;

&lt;p&gt;shell subshell subsubshell&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
### 反引号（backticks）

在上面我们可以通过`$()`将子`shell`嵌入命令行中，为了方便，我们同样可以用反引号`` ` ``将子`shell`嵌入。

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;var1-hello-2&#34;&gt;var1=hello&lt;/h1&gt;

&lt;h1 id=&#34;echo-var1-world-echo-var1-1&#34;&gt;echo &lt;code&gt;var1=world; echo $var1&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;world&lt;/p&gt;

&lt;h1 id=&#34;echo-var1-1&#34;&gt;echo $var1&lt;/h1&gt;

&lt;p&gt;hello&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
但是，使用反引号不能够嵌套子`shell`，因此如果需要嵌套子`shell`时，只能使用`$()`。

&amp;gt; 反引号跟单引号是本质的不同的，单引号与双引号一样，用来将连续的字串作为整体引起来，只不过单引号中将不执行变量的引用解析，而反引号则是嵌入子`shell`。


## `shell`选项

其实在前面咱们已经使用了不少`shell`的选项，如`set -u`在变量不存在是报错，`set -x`将`shell`展开的结果显示出来等。此外，可以才用`echo $-`将当期设置的`shell`选项打印出来。

# `shell`历史记录

在`shell`中执行命令的时候，`shell`会将最近的命令使用历史记录下来，这样你可以很方便的查看最近做了什么操作。

## 查看历史记录

命令`history`可以用来查看`shell`的历史记录，里面记录了你最近输入的所有命令。当然，很多时候你更加关心最近的几个命令，你可以使用`history 10`来显示最近的10个命令。另外，`shell`通常还会将最近的历史记录写在`~/.bash_history`文件中，因此查看该文件同样可以查看历史记录。

## 执行历史的命令

`shell`提供了很多高级用法使得你可以很方便的执行以前执行过的命令。

首先，咱们先显示一下过去的10个命令，可以看到每个命令前面都有其对应的序号。

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;history-10&#34;&gt;history 10&lt;/h1&gt;

&lt;p&gt;1000  history
 1001  history 10
 1002  echo &amp;ldquo;hello world&amp;rdquo;
 1003  ls -l
 1004  ps -ef | grep named
 1005  env | grep http
 1006  grep hello /var/log/messages
 1007  tmux ls
 1008  find . -name &amp;ldquo;hello&amp;rdquo;
 1009  history 10&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
下面列举比较常用的`shell`重复执行历史记录中命令的方法：

| 命令      | 说明                                                                                                  |
|-----------|-------------------------------------------------------------------------------------------------------|
| !!        | 在`shell`中输入两个感叹号会执行上一个命令                                                             |
| !keyword  | 输入一个感叹号后跟关键字，会搜索历史记录中最先以该关键字开始的命令。如`!find`会执行序号为1008的命令。 |
| !?keyword | 执行历史记录中第一个包括keyword关键字的命令                                                           |
| !n        | 其中n代表历史记录中的序号，表示执行序号为n的命令。                                                    |
| !-n       | 执行倒数第n个命令，如`!-1`其实就相当于`!!`                                                            |
| cmd!*     | 执行命令`cmd`，其中`!*`会以上一条命令的所有参数替代                                                   |

另外，对于`!keyword`的用法，还有一个高级功能，你可以将符合该条件的命令进行改造后执行，如：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;echo-test1&#34;&gt;echo &amp;ldquo;test1&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;test1&lt;/p&gt;

&lt;h1 id=&#34;ec-s-1-2&#34;&gt;!ec:s/1/2/&lt;/h1&gt;

&lt;p&gt;echo &amp;ldquo;test2&amp;rdquo;
test2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
其中，`:s/1/2/`将命令`echo &amp;quot;test1&amp;quot;`替换成`echo &amp;quot;test2&amp;quot;`然后执行了。对于`cmd!*`，示例如下：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ctt-etc-passwd-cut-d-f1&#34;&gt;ctt /etc/passwd | cut -d: -f1&lt;/h1&gt;

&lt;p&gt;-bash: ctt: command not found&lt;/p&gt;

&lt;h1 id=&#34;cat&#34;&gt;cat !*&lt;/h1&gt;

&lt;p&gt;cat /etc/passwd | cut -d: -f1
root
bin
daemon
adm
&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
## 搜索历史记录

在`shell`终端中按Ctrl-r会打开`shell`的搜索模式，在改模式下输入关键字会显示最近包含改关键字的命令，再按一下Ctrl-r会继续显示前面一条符合条件的命令，找到你需要的命令后回车就可以执行改命令了。

## 修改历史记录的有关配置

有多个配置可以用来改变历史记录的有关信息，通常都是通过有关环境变量来配置：

| 环境变量      | 说明                                                                                       |
|---------------|--------------------------------------------------------------------------------------------|
| $HISTSIZE     | 这个变量用来配置`shell`应该保持多少行的历史记录，在很多发行版本中，默认值一般为500或者1000 |
| $HISTFILE     | 这个变量用来配置历史记录文件存放的位置，通常来讲，默认路径为`~/.bash_history`              |
| $HISTFILESIZE | 这个变量用来配置历史记录文件可以存放多少行的历史记录                                       |

## 阻止记录某些命令

在有些时候，我们并不想把某些命令记录在历史记录中，比如有的命令里面包括了敏感信息如密码等。在新版本的`shell`中，通常我们可以在输入的命令前面加入空格，这样`shell`就不会记录这样的命令，当然，如果你的发行版本默认并不支持，你可以配置环境变量来打开这个功能：

```sh
export HISTIGNORE=&amp;quot;[ \t]*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# history 5
 1023  ls -l
 1024  echo &amp;quot;&amp;quot;
 1025  history 5
 1026  ls
 1027  history 5
#  echo &amp;quot;password=123456&amp;quot;
password=123456
# history 5
 1025  history 5
 1026  ls
 1027  history 5
 1028   echo &amp;quot;password=123456&amp;quot;
 1029  history 5
# export HISTIGNORE=&amp;quot;[ \t]*&amp;quot;
# history 5
 1027  history 5
 1028   echo &amp;quot;password=123456&amp;quot;
 1029  history 5
 1030  export HISTIGNORE=&amp;quot;[ \t]*&amp;quot;
 1031  history 5
#  echo &amp;quot;password=123456&amp;quot;
password=123456
# history 5
 1027  history 5
 1028   echo &amp;quot;password=123456&amp;quot;
 1029  history 5
 1030  export HISTIGNORE=&amp;quot;[ \t]*&amp;quot;
 1031  history 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，在设置&lt;code&gt;$HISTIGNORE&lt;/code&gt;变量之后，在前面加了空格的命令将不再记录。这在保护敏感信息的时候非常有用。&lt;/p&gt;

&lt;h1 id=&#34;文件匹配-file-globbing&#34;&gt;文件匹配(File Globbing)&lt;/h1&gt;

&lt;p&gt;文件匹配(File Globbing)又成为动态文件名生成，用它可以非常方便的在&lt;code&gt;shell&lt;/code&gt;中输入文件名。&lt;/p&gt;

&lt;h2 id=&#34;星号&#34;&gt;&lt;code&gt;*&lt;/code&gt;星号&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;星号在&lt;code&gt;shell&lt;/code&gt;中用来匹配任意数量的字符，比如文件名&lt;code&gt;File*.mp4&lt;/code&gt;，将匹配以&lt;code&gt;File&lt;/code&gt;开头，&lt;code&gt;.mp4&lt;/code&gt;结尾的任何文件名。&lt;code&gt;shell&lt;/code&gt;在扫描解释命令的时候会自动去查找符合该匹配的所有文件或目录。当然，你也可以只用&lt;code&gt;*&lt;/code&gt;来匹配所有的文件及目录，但请注意，只使用&lt;code&gt;*&lt;/code&gt;跟不带&lt;code&gt;*&lt;/code&gt;还是有所区别的，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls
definition.yaml  example  __init__.py  tags.yaml  test.py  test_sample.html  test_sample.py
# ls *
definition.yaml  __init__.py  tags.yaml  test.py  test_sample.html  test_sample.py

example:
testcase
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，带上&lt;code&gt;*&lt;/code&gt;后不仅把当前目录的所有文件及目录显示出来，而且还把目录下的内容显示出来了。&lt;/p&gt;

&lt;h2 id=&#34;问号&#34;&gt;&lt;code&gt;?&lt;/code&gt;问号&lt;/h2&gt;

&lt;p&gt;问号用来匹配一个字符，如&lt;code&gt;File?.mp4&lt;/code&gt;可以匹配&lt;code&gt;File1.mp4&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;方括号&#34;&gt;&lt;code&gt;[]&lt;/code&gt;方括号&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[]&lt;/code&gt;方括号也用来匹配一个字符，但是在括号里面可以指定一个字符集用来限定匹配的字符必须在该字符集内，字符集里面的字符顺序没有关系。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
# ls File[5A]
FileA
# ls File[A5]
FileA
# ls File[A5][5b]
File55
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要匹配不在某个字符集里面的字符，可以在&lt;code&gt;[]&lt;/code&gt;第一个字符加入&lt;code&gt;!&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls file[!5]*
file1  file2  file3  fileab  fileabc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特别的，为了方便，&lt;code&gt;[]&lt;/code&gt;中可以使用&lt;code&gt;-&lt;/code&gt;来定义一些连续的字符集（Range匹配），常用的这类字符集包括：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符集&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0-9&lt;/td&gt;
&lt;td&gt;表示数字字符集&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a-z&lt;/td&gt;
&lt;td&gt;表示小写字母字符集&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;A-Z&lt;/td&gt;
&lt;td&gt;表示大写字母字符集&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当然，你也不必要把所有范围都包括在内，如&lt;code&gt;[a-d]&lt;/code&gt;可以用来限定从&lt;code&gt;a&lt;/code&gt;到&lt;code&gt;d&lt;/code&gt;的小写字母集。另外，用&lt;code&gt;-&lt;/code&gt;连起来的字符集还可以跟其它字符集一起使用，如&lt;code&gt;[a-d_]&lt;/code&gt;表示&lt;code&gt;a&lt;/code&gt;到&lt;code&gt;d&lt;/code&gt;的小写字母加上&lt;code&gt;_&lt;/code&gt;所组成的字符集。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Range匹配的大小写问题&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;[]&lt;/code&gt;的Range匹配，还有一点很重要。在很多发行版本中，默认情况下，&lt;code&gt;[]&lt;/code&gt;的Range匹配是忽略大小写的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls
Test1  test2
# ls [a-z]*
Test1  test2
# ls [A-Z]*
Test1  test2
# ls [t]*
test2
# ls [T]*
Test1
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，是&lt;code&gt;[]&lt;/code&gt;的Range匹配会忽略大小写，而如果不是Range匹配还是大小写敏感的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; # ls
&amp;gt; Test1  test2
&amp;gt; # ls [T]*
&amp;gt; Test1
&amp;gt; # ls [t]*
&amp;gt; test2
&amp;gt; ```

如果需要大小写敏感，可以设置环境变量`LC_ALL`：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;lc-all-c&#34;&gt;LC_ALL=C&lt;/h1&gt;

&lt;h1 id=&#34;ls-a-z&#34;&gt;ls [a-z]*&lt;/h1&gt;

&lt;p&gt;test2&lt;/p&gt;

&lt;h1 id=&#34;ls-a-z-1&#34;&gt;ls [A-Z]*&lt;/h1&gt;

&lt;p&gt;Test1
```&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然，请务必注意，&lt;code&gt;LC_ALL&lt;/code&gt;的会改变当前的语言环境，还请慎重使用，建议只在临时的子&lt;code&gt;shell&lt;/code&gt;中使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;阻止文件匹配-file-globbing&#34;&gt;阻止文件匹配(File Globbing)&lt;/h2&gt;

&lt;p&gt;有时候我们就是需要输出&lt;code&gt;*&lt;/code&gt;等匹配符号，这个时候就需要阻止&lt;code&gt;shell&lt;/code&gt;做相应的匹配。可以使用转义符号&lt;code&gt;\&lt;/code&gt;来做到这点，或者将匹配符号放在引号中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo *
Test1 test2
# echo \*
*
# echo &#39;*&#39;
*
# echo &amp;quot;*&amp;quot;
*
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;shell快捷键&#34;&gt;shell快捷键&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;中支持非常多的快捷键，可以非常方便我们输入命令：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl-d&lt;/td&gt;
&lt;td&gt;表示&lt;code&gt;EOF&lt;/code&gt;的意思，在shell终端中输入该快捷键会退出该终端&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-z&lt;/td&gt;
&lt;td&gt;该快捷键用来暂停一个在shell终端中正在执行的进程，暂停后可以用&lt;code&gt;fg&lt;/code&gt;命令恢复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-a&lt;/td&gt;
&lt;td&gt;输入命令时跳到行首&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-e&lt;/td&gt;
&lt;td&gt;跳到行尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-k&lt;/td&gt;
&lt;td&gt;删除从光标到行尾的部分&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-y&lt;/td&gt;
&lt;td&gt;粘贴刚刚删除的部分&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-w&lt;/td&gt;
&lt;td&gt;删除从光标至其左边第一个空格处&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（一）命令行</title>
      <link>https://keysaim.github.io/post/linux/2017-10-09-linux-study-command-line/</link>
      <pubDate>Mon, 09 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-10-09-linux-study-command-line/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;随着Linux的发展，现在已经有了非常多的桌面版本，比如著名的Ubuntu。用这些桌面版本系统，可以满足基本的操作，然而对于一些高级点的操作，还是离不开Linux的命令行(Command Line)。而Linux的精髓也更多的体现在命令行上，其强大的功能，海量的工具，可以帮你轻而易举的完成各种复杂的系统管理操作。本文将详细讲述Linux命令行。&lt;/p&gt;

&lt;h1 id=&#34;基础命令&#34;&gt;基础命令&lt;/h1&gt;

&lt;h2 id=&#34;帮助类&#34;&gt;帮助类&lt;/h2&gt;

&lt;h3 id=&#34;man&#34;&gt;man&lt;/h3&gt;

&lt;p&gt;Linux有着海量的命令，而每个命令又有很多的不同参数，要记住所有的这些命令是比较困难的，因此，在使用Linux命令行的时候，必须时刻记着查看Linux的帮助，而查看帮助就是采用&lt;code&gt;man&lt;/code&gt;命令。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看命令帮助&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;ls&lt;/code&gt;命令为例，如果要查看帮助的话可以输入&lt;code&gt;man ls&lt;/code&gt;，查看基本的帮助信息也可以直接&lt;code&gt;ls --help&lt;/code&gt;。其将以分页的形式显示该命令的完整文档，操作该文档的基本命令有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按&lt;code&gt;u&lt;/code&gt;上翻页&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;d&lt;/code&gt;下翻页&lt;/li&gt;
&lt;li&gt;按空格下翻页&lt;/li&gt;
&lt;li&gt;按回车下移一行&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;/&lt;/code&gt;进入搜索模式，输入要搜索的关键字，按回车搜索。&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;n&lt;/code&gt;搜索下一个&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;N&lt;/code&gt;搜索上一个&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;q&lt;/code&gt;退出查看&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看配置文件的帮助&lt;/p&gt;

&lt;p&gt;有些系统的配置文件也同样有对应的帮助文档，可以通过&lt;code&gt;man $configfile&lt;/code&gt;来查看，比如&lt;code&gt;/etc/system/sysctl.conf&lt;/code&gt;配置文件，查看其帮助可以采用命令&lt;code&gt;man sysctl.conf&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看后台进程(daemon)的帮助&lt;/p&gt;

&lt;p&gt;Linux在后台运行着很多的程序（称为daemon），如果需要查看某个daemon的帮助，可以用命令&lt;code&gt;man $daemon&lt;/code&gt;来查看。如&lt;code&gt;man ntpd&lt;/code&gt;将查看时间同步daemon的帮助文档。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;搜索需要查看的命令&lt;/p&gt;

&lt;p&gt;Linux命令实在太多，有时候如果不记得准确的命令的名字，可以采用&lt;code&gt;man -k $keyword&lt;/code&gt;来搜索，如&lt;code&gt;man -k syslog&lt;/code&gt;将列出相关命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# man -k syslog
ipmievd (8)          - IPMI event daemon for sending events to syslog
logger (1)           - a shell command interface to the syslog(3) system log module
rsyslog.conf (5)     - rsyslogd(8) configuration file
rsyslogd (8)         - reliable and extended syslogd
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;whatis&#34;&gt;whatis&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;man&lt;/code&gt;命令将展示完整的文档，可以通过&lt;code&gt;whatis&lt;/code&gt;来查看命令的简单介绍。&lt;/p&gt;

&lt;h3 id=&#34;whereis&#34;&gt;whereis&lt;/h3&gt;

&lt;p&gt;如果需要知道某个命令的完整路径，可以采用&lt;code&gt;whereis $command&lt;/code&gt;来查看。&lt;/p&gt;

&lt;h2 id=&#34;目录操作类&#34;&gt;目录操作类&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;td&gt;查看当前目录路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd $path&lt;/td&gt;
&lt;td&gt;切换到其它路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd ~&lt;/td&gt;
&lt;td&gt;返回home目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd ..&lt;/td&gt;
&lt;td&gt;返回上一级&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd -&lt;/td&gt;
&lt;td&gt;返回上一次的目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ls $path&lt;/td&gt;
&lt;td&gt;查看目录下的内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ls -a&lt;/td&gt;
&lt;td&gt;显示目录下所有文件，包括隐藏文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ls -lh&lt;/td&gt;
&lt;td&gt;列表的形式显示，&lt;code&gt;-h&lt;/code&gt;以可读的方式显示大小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mkdir&lt;/td&gt;
&lt;td&gt;创建目录，要递归创建采用&lt;code&gt;mkdir -p&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;文件操作类&#34;&gt;文件操作类&lt;/h2&gt;

&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大小写敏感
在Linux系统中，文件名都是大小写敏感的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有都是文件
Linux基本上将文件，目录，设备等等都视为文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;file命令&#34;&gt;file命令&lt;/h3&gt;

&lt;p&gt;查看文件的类型，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# file bugs.tgz
bugs.tgz: gzip compressed data, from Unix, last modified: Tue Dec 13 01:38:27 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以显示文件的类型及修改时间等信息。查看特殊文件如设备文件的时候，还可以带上&lt;code&gt;-s&lt;/code&gt;的参数，这样可以识别更多的信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# file /dev/sda
/dev/sda: block special
# file -s /dev/sda
/dev/sda: x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 1024000 sectors; partition 2: ID=0x8e, starthead 221, startsector 1026048, 208689152 sectors, code offset 0x63
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;touch&#34;&gt;touch&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;touch&lt;/code&gt;用来创建空文件，或者用来更新文件时间为当前时间。如果加上&lt;code&gt;-t&lt;/code&gt;参数，可以为文件设置指定的时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# date
Mon Oct  9 03:19:24 EDT 2017
# ls -l
total 4
-rw-r--r--. 1 root root 6 Jun 19  2016 login.html
# touch test.txt
# ls -l
total 4
-rw-r--r--. 1 root root 6 Jun 19  2016 login.html
-rw-r--r--. 1 root root 0 Oct  9 03:19 test.txt
# touch login.html
# ls -l
total 4
-rw-r--r--. 1 root root 6 Oct  9 03:19 login.html
-rw-r--r--. 1 root root 0 Oct  9 03:19 test.txt
# touch -t 201701011010 login.html
# ls -l
total 4
-rw-r--r--. 1 root root 6 Jan  1  2017 login.html
-rw-r--r--. 1 root root 0 Oct  9 03:19 test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;删除-复制-移动&#34;&gt;删除、复制、移动&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;rm&lt;/td&gt;
&lt;td&gt;永久删除一个文件，对于此命令，没有所谓的垃圾箱，请慎重&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rm -i&lt;/td&gt;
&lt;td&gt;询问是否真的要删除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rm -rf&lt;/td&gt;
&lt;td&gt;通常&lt;code&gt;rm&lt;/code&gt;只是删除文件，如果需要删除目录的时候，必须带上&lt;code&gt;-r&lt;/code&gt;参数，&lt;code&gt;-f&lt;/code&gt;参数表示强制删除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cp&lt;/td&gt;
&lt;td&gt;拷贝文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cp -rf&lt;/td&gt;
&lt;td&gt;拷贝目录下所有的文件，并强制覆盖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mv&lt;/td&gt;
&lt;td&gt;移动文件到另一个目录，或者在当前目录下对某个文件改名字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;文件内容操作类&#34;&gt;文件内容操作类&lt;/h2&gt;

&lt;h3 id=&#34;head&#34;&gt;head&lt;/h3&gt;

&lt;p&gt;查看某个文件的头几行，可以用&lt;code&gt;head&lt;/code&gt;命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# head -n 5 /var/log/messages
Oct  9 03:10:01 traffic-base1 rsyslogd: [origin software=&amp;quot;rsyslogd&amp;quot; swVersion=&amp;quot;7.4.7&amp;quot; x-pid=&amp;quot;697&amp;quot; x-info=&amp;quot;http://www.rsyslog.com&amp;quot;] rsyslogd was HUPed
Oct  9 03:20:01 traffic-base1 systemd: Started Session 79213 of user root.
Oct  9 03:20:01 traffic-base1 systemd: Starting Session 79213 of user root.
Oct  9 03:28:26 traffic-base1 puppet-agent[14530]: Unable to fetch my node definition, but the agent run will continue:
Oct  9 03:28:26 traffic-base1 puppet-agent[14530]: Connection refused - connect(2)
# head -c 5 /var/log/messages
Oct  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-n&lt;/code&gt;参数表示显示多少行，不带此参数，默认显示10行。&lt;code&gt;-c&lt;/code&gt;表示显示多少个字符，这里显示了前面5个字符。&lt;/p&gt;

&lt;h3 id=&#34;tail&#34;&gt;tail&lt;/h3&gt;

&lt;p&gt;与&lt;code&gt;head&lt;/code&gt;相反，&lt;code&gt;tail&lt;/code&gt;用来显示文件最后几行。同样&lt;code&gt;-n&lt;/code&gt;可以用来限制多少行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tail&lt;/code&gt;有个非常重要的用处，&lt;strong&gt;&lt;em&gt;就是用来监听某个动态文件的内容，比如实时查看某个日志文件&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# tail -n 5 -F /var/log/messages
Oct  9 03:28:27 traffic-base1 puppet: from /usr/share/ruby/vendor_ruby/puppet/util/command_line.rb:146:in `run&#39;
Oct  9 03:28:27 traffic-base1 puppet: from /usr/share/ruby/vendor_ruby/puppet/util/command_line.rb:92:in `execute&#39;
Oct  9 03:28:27 traffic-base1 puppet: from /usr/bin/puppet:8:in `&amp;lt;main&amp;gt;&#39;
Oct  9 03:30:01 traffic-base1 systemd: Started Session 79218 of user root.
Oct  9 03:30:01 traffic-base1 systemd: Starting Session 79218 of user root.
Oct  9 03:40:01 traffic-base1 systemd: Started Session 79223 of user root.
Oct  9 03:40:01 traffic-base1 systemd: Starting Session 79223 of user root.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它将不停的侦听文件的改变，并实时的将最后新写入的行打印出来。&lt;/p&gt;

&lt;h3 id=&#34;cat-file1-file2-file3&#34;&gt;cat $file1 $file2 $file3 &amp;hellip;&lt;/h3&gt;

&lt;p&gt;要显示文件的所有内容，可以用&lt;code&gt;cat&lt;/code&gt;命令。&lt;code&gt;cat&lt;/code&gt;也可以用来创建新文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat &amp;gt; test.txt
Today is a good day!
# cat test.txt
Today is a good day!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以直接输入文件内容了，输入完成之后按Ctrl+d结束输入。当然，也可以定制结束符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat &amp;gt; test.txt &amp;lt;&amp;lt;stop
&amp;gt; It&#39;s a good day!
&amp;gt; stop
# cat test.txt
It&#39;s a good day!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tac&#34;&gt;tac&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;tac&lt;/code&gt;名字其实就是&lt;code&gt;cat&lt;/code&gt;倒过来写，所以其作用也是一样，就是把文件以倒着的顺序显示出来。&lt;/p&gt;

&lt;h3 id=&#34;more跟less&#34;&gt;more跟less&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cat&lt;/code&gt;会直接把整个文件一次性的显示出来，当文件较大时，显示可能会刷屏，这样不利于查看。如果需要以翻页的形式显示文件的内容，可以采用&lt;code&gt;more&lt;/code&gt;或者&lt;code&gt;less&lt;/code&gt;命令，其查看方式跟&lt;code&gt;man&lt;/code&gt;命令的查看方式类似，可以参考前面的说明。&lt;/p&gt;

&lt;h3 id=&#34;strings&#34;&gt;strings&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;strings&lt;/code&gt;命令会将文件中的可读字符显示出来，即便改文件是一个二进制文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# strings a.out | tail -n 5
_edata
_Znwm@@GLIBCXX_3.4
_ZN3Out5InnerC1EPS_
main
_init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;a.out&lt;/code&gt;是一个二进制文件。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（二）文件系统结构</title>
      <link>https://keysaim.github.io/post/linux/2017-10-09-linux-study-file-system-hierarchy/</link>
      <pubDate>Mon, 09 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-10-09-linux-study-file-system-hierarchy/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;多数Linux发行版本都是遵循&lt;code&gt;文件系统结构标准（Filesystem Hierarchy Standard, 简称FHS）&lt;/code&gt;，可以在&lt;a href=&#34;http://www.pathname.com/fhs/&#34;&gt;这里&lt;/a&gt;找到该标准。本文对Linux的文件系统结构进行简单的介绍。&lt;/p&gt;

&lt;h1 id=&#34;根目录&#34;&gt;根目录&lt;code&gt;/&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;所有的Linux系统都有根目录，由&lt;code&gt;/&lt;/code&gt;表示。Linux系统的所有内容都在该目录下。&lt;/p&gt;

&lt;h1 id=&#34;二进制目录&#34;&gt;二进制目录&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/bin&lt;/td&gt;
&lt;td&gt;包括了可执行的二进制文件，通常这些二进制文件可以被所有用户访问。FHS规定，该目录至少包括&lt;code&gt;/bin/cat&lt;/code&gt;跟&lt;code&gt;/bin/date&lt;/code&gt;文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/sbin&lt;/td&gt;
&lt;td&gt;包括了系统的二进制文件，通过需要root权限，用来配置系统&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/lib&lt;/td&gt;
&lt;td&gt;包括了&lt;code&gt;/bin&lt;/code&gt;所依赖的库&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/lib/modules&lt;/td&gt;
&lt;td&gt;Linux将从&lt;code&gt;/lib/modules/$kernel-version/&lt;/code&gt;目录下载入内核模块&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/lib32和/lib64&lt;/td&gt;
&lt;td&gt;顾名思义，分别存放不同位数的库&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/opt&lt;/td&gt;
&lt;td&gt;该目录用来存放一些可选的软件，通常情况下，很多第三方的客户软件会选择安装在该目录下&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;配置文件目录&#34;&gt;配置文件目录&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/boot&lt;/td&gt;
&lt;td&gt;顾名思义，用来存放系统启动的配置文件，如grub引导的配置文件&lt;code&gt;/boot/grub/grub.cfg&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/etc&lt;/td&gt;
&lt;td&gt;几乎大部分配置文件都放在改目录下。历史上&lt;code&gt;etc&lt;/code&gt;的全称是&lt;code&gt;etcetera&lt;/code&gt;，不过，现在一般认为是&lt;code&gt;Editable Text Configuration&lt;/code&gt;的缩写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/etc/init.d&lt;/td&gt;
&lt;td&gt;存放daemon启动、停止等的脚本文件。不过在引入systemd之后，启动脚本有所变化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/etc/skel&lt;/td&gt;
&lt;td&gt;存放创建新用户之后所需的配置文件的模板，如&lt;code&gt;.bashrc&lt;/code&gt;文件，默认会从该目录拷贝到用户目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/etc/sysconfig&lt;/td&gt;
&lt;td&gt;一般出现在RedHat系列的Linux系统中，存放系统有关配置，如IP的配置文件等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;数据目录&#34;&gt;数据目录&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;当创建一个新用户的时候，默认情况下，系统会为用户创建一个&lt;code&gt;/home/&amp;lt;username&amp;gt;&lt;/code&gt;的目录用来存放个人数据。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/root&lt;/td&gt;
&lt;td&gt;该目录被很多Linux系统用来存放root用户的个人数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/srv&lt;/td&gt;
&lt;td&gt;可以被解释为&lt;code&gt;served by your system&lt;/code&gt;。FHS允许&lt;code&gt;rsync&lt;/code&gt;，&lt;code&gt;ftp&lt;/code&gt;，&lt;code&gt;www&lt;/code&gt;等数据存放在改目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/media&lt;/td&gt;
&lt;td&gt;该目录通常被用来挂载可移除设备，如CD-ROM，U盘等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/mnt&lt;/td&gt;
&lt;td&gt;根据FHS，该目录通常被用来作为短期的挂载点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/tmp&lt;/td&gt;
&lt;td&gt;该目录用来存放一些短期的文件，&lt;strong&gt;&lt;em&gt;不要再该目录下存放重要文件，该目录下的文件有可能会被系统回收&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;内存目录&#34;&gt;内存目录&lt;/h1&gt;

&lt;p&gt;Linux系统中，几乎所有的东西都被映射成文件，文件有的是对应着硬盘、设备（CD-ROM等）等，有的则被Linux映射到内存中。这一节介绍映射到内存中的目录。&lt;/p&gt;

&lt;h2 id=&#34;dev目录&#34;&gt;/dev目录&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;/dev&lt;/code&gt;目录映射了各种设备文件，这些文件由系统启动的时候扫描硬件生成。&lt;/p&gt;

&lt;h3 id=&#34;物理设备文件&#34;&gt;物理设备文件&lt;/h3&gt;

&lt;p&gt;物理设备包括很多种，如硬盘，CD-ROM等。不同的物理设备映射为&lt;code&gt;/dev&lt;/code&gt;目录下不同的文件。如SATA/SCSI设备或USB通常被映射为&lt;code&gt;/dev/sd*&lt;/code&gt;，其中&lt;code&gt;*&lt;/code&gt;可以为&lt;code&gt;[a-z]&lt;/code&gt;中的任意字符；而IDE设备通常被映射为&lt;code&gt;/dev/hd*&lt;/code&gt;，其中&lt;code&gt;*&lt;/code&gt;为&lt;code&gt;[a-z]&lt;/code&gt;中任意字符。&lt;/p&gt;

&lt;h3 id=&#34;dev-tty跟-dev-pts&#34;&gt;/dev/tty跟/dev/pts&lt;/h3&gt;

&lt;p&gt;首先需要搞清楚&lt;code&gt;tty&lt;/code&gt;设备跟&lt;code&gt;pts&lt;/code&gt;设备的区别。这两者都是终端设备，所谓终端设备通常指的是能够接受命令输入，并可能同时能够输出的设备，但是这两者是有本质的不同的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;tty设备&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tty&lt;/code&gt;是&lt;code&gt;Teletype&lt;/code&gt;的简称，表示原生的终端设备，通常指的是物理终端设备如串口，键鼠接口等，以及系统内核模拟的终端设备。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pts设备&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pts&lt;/code&gt;是&lt;code&gt;Pseudo Terminal Slave&lt;/code&gt;的简称，表示伪终端设备，通常由应用进程模拟出来，如ssh开启的终端等。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;tty&lt;/code&gt;设备通常被映射为&lt;code&gt;/dev/tty*&lt;/code&gt;，其中&lt;code&gt;*&lt;/code&gt;代表数字，如&lt;code&gt;/dev/tty1&lt;/code&gt;等。而&lt;code&gt;pts&lt;/code&gt;设备被映射为&lt;code&gt;/dev/pts/*&lt;/code&gt;，其中&lt;code&gt;*&lt;/code&gt;表示数字，如&lt;code&gt;/dev/pts/1&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;dev-null&#34;&gt;/dev/null&lt;/h3&gt;

&lt;p&gt;该文件在Linux中有着特殊的意义，是一个只有输入的文件，且文件有无限的大小，你不能从该文件读出任何东西，任何写入的内容逻辑上相当于消失了。从实现的角度，实际上任何写入的内容都被系统丢弃了。&lt;/p&gt;

&lt;h2 id=&#34;proc目录&#34;&gt;/proc目录&lt;/h2&gt;

&lt;p&gt;该目录用来记录内核以及内核进程的实时信息，可以通过它轻而易举的实现对内核状态的获取甚至改变。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/proc/&lt;id&gt;&lt;/td&gt;
&lt;td&gt;几乎每个进程都会在该目录下有映射的文件&lt;code&gt;/proc/*&lt;/code&gt;，其中&lt;code&gt;&amp;lt;id&amp;gt;&lt;/code&gt;代表进程的ID。该目录记录的该进程的几乎所有的状态信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/cpuinfo&lt;/td&gt;
&lt;td&gt;记录了系统的CPU信息，通常通过该文件可以知道系统有多少个CPU（核数）。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/meminfo&lt;/td&gt;
&lt;td&gt;记录了系统的内存信息，可以通过它知道系统有多少内存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/sys&lt;/td&gt;
&lt;td&gt;在&lt;code&gt;/proc&lt;/code&gt;目录下的绝大部分文件都是只读的文件，但是在该目录下有些文件是可写的，可以通过它们改变内核状态&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/interrupts&lt;/td&gt;
&lt;td&gt;记录了当前系统的中断信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/kcore&lt;/td&gt;
&lt;td&gt;这个文件代表了系统的物理内存，其大小就是物理内存的大小，因此千万不要用&lt;code&gt;cat&lt;/code&gt;来试图显示该文件内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;usr目录&#34;&gt;/usr目录&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;/usr&lt;/code&gt;目录估计是被误解最多的目录，一般大家都以为它是&lt;code&gt;user&lt;/code&gt;的简写，感觉应该存放的是用户相关的东西，但是实际上完全不是这样。它其实是&lt;code&gt;Unix System Resources&lt;/code&gt;的简写，表示Unix系统资源。通常情况下，该目录以只读的权限被挂载。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/usr/bin&lt;/td&gt;
&lt;td&gt;很多命令都存放在这个目录下面，事实上，在Centos跟Solaris系统中，&lt;code&gt;/bin&lt;/code&gt;目录实际上只是一个软连接，连接到此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/include&lt;/td&gt;
&lt;td&gt;存放大量的头文件，可能会被C代码引用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/lib&lt;/td&gt;
&lt;td&gt;存放库文件，同样，在Centos跟Solaris系统中，&lt;code&gt;/lib&lt;/code&gt;其实就是软连接到此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/lib64&lt;/td&gt;
&lt;td&gt;存放64位的库文件，在Centos中，&lt;code&gt;/lib64&lt;/code&gt;也是软连接到此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/sbin&lt;/td&gt;
&lt;td&gt;很多daemon程序都是放在此目录下，在Centos中，&lt;code&gt;/sbin&lt;/code&gt;也是软连接到此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/local&lt;/td&gt;
&lt;td&gt;此目录通常用来安装一些本地的应用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/share&lt;/td&gt;
&lt;td&gt;此目录通常用来存放各种体系无关的数据。&lt;code&gt;/usr/share/man&lt;/code&gt;就是用来存放&lt;code&gt;man&lt;/code&gt;命令用到的帮助文档&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/src&lt;/td&gt;
&lt;td&gt;此目录通常存放内核的代码文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;var目录&#34;&gt;/var目录&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;/var&lt;/code&gt;目录用来存放可变的数据，如日志，数据库文件等。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/var/log&lt;/td&gt;
&lt;td&gt;此目录用来存放各种日志文件，包括系统跟应用的日志&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/log/messages&lt;/td&gt;
&lt;td&gt;在RedHat系列系统中，此文件用来记录系统刚刚发生的事情。在Debian和Ubuntu系统中，对应的文件是&lt;code&gt;/var/log/syslog&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/cache&lt;/td&gt;
&lt;td&gt;此目录存放很多应用的缓存数据，如&lt;code&gt;yum&lt;/code&gt;命令可能会缓存部分数据在此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/spool&lt;/td&gt;
&lt;td&gt;一般情况下，该目录会存放邮件cron任务等数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/lib&lt;/td&gt;
&lt;td&gt;通常此目录下会存放应用的状态信息，如&lt;code&gt;/var/lib/mysql&lt;/code&gt;存放&lt;code&gt;mysql&lt;/code&gt;数据库，&lt;code&gt;/var/lib/docker&lt;/code&gt;存放&lt;code&gt;docker&lt;/code&gt;的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍--综述</title>
      <link>https://keysaim.github.io/post/linux/2017-10-09-linux-study-overview/</link>
      <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-10-09-linux-study-overview/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;从大二（2006年）开始接触Linux到现在已经有10几年了，遥记得那时候Ubuntu还是个位数时代，现在都到17了，真的是光阴如梭啊。这这些年里面，Linux也有了长足的发展，是时候再次系统的对Linux进行重新学习了，所谓温故而知新，何况Linux本身也有很多新的变化。本系列博文将基于博主的&lt;a href=&#34;https://keysaim.github.io/2017/08/18/linux-learning-materials/&#34;&gt;这一篇&lt;/a&gt;博文中推荐的书籍为基础，结合一些网上的资料，对Linux进行一次系统的整理。希望通过此次整理能够使自己对Linux的理解更进一步，也希望能够给读者一定的参考。&lt;/p&gt;

&lt;h1 id=&#34;说明&#34;&gt;说明&lt;/h1&gt;

&lt;p&gt;本系列博文中各种例子都将基于Centos 7的Linux系统，可能与其它发行版本会有些许出入，还望读者留意。&lt;/p&gt;

&lt;h1 id=&#34;相关博文&#34;&gt;相关博文&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/10/09/linux-study-command-line/&#34;&gt;Linux系统介绍（一）命令行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/10/09/linux-study-file-system-hierarchy/&#34;&gt;Linux系统介绍（二）文件系统结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/10/10/linux-study-shell-basic/&#34;&gt;Linux系统介绍（三）shell基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/11/16/linux-study-io-pipe/&#34;&gt;Linux系统学习（四）IO重定向与管道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/11/17/linux-study-common-tools/&#34;&gt;Linux系统介绍（五）常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本系列博文将持续更新，并在此章节中进行统一整理。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>如何搭建本地的Git服务器</title>
      <link>https://keysaim.github.io/post/git/2017-09-04-how-to-setup-git-server/</link>
      <pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/git/2017-09-04-how-to-setup-git-server/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;本文将介绍如何在本地搭建Git服务器。我们知道Git其实是个分布式的版本管理系统，与中心化的版本管理系统如SVN有根本的不同，每个使用者都可以在本地存储一份独立的备份，每个Git的使用者并不会因为没有中心服务器而不能工作（如果是SVN之类的，如果服务器挂了是不能够提交改动的）。然而，在进行团队开发的时候，有时候还是非常需要有一个统一的地方管理唯一的一份完整的代码，这样可以非常方便的进行团队协作开发。这里讲述一种极为简单的搭建本地Git服务器的方法。&lt;/p&gt;

&lt;h1 id=&#34;如何搭建&#34;&gt;如何搭建&lt;/h1&gt;

&lt;h2 id=&#34;准备一台linux服务器&#34;&gt;准备一台Linux服务器&lt;/h2&gt;

&lt;p&gt;这里不考虑windows系统，所以请务必准备一台Linux系统，分发版本没有关系，这里假定使用的是&lt;code&gt;Centos 7&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;配置git服务器&#34;&gt;配置Git服务器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加用户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ sudo adduser git
$ sudo passwd git
Changing password for user git.
New password:
Retype new password:
passwd: all authentication tokens updated successfully.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置好ssh&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ sudo su git
$ cd
$ mkdir .ssh &amp;amp;&amp;amp; chmod 700 .ssh
$ touch .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;初始化项目&#34;&gt;初始化项目&lt;/h2&gt;

&lt;p&gt;假定我们有一个叫&lt;code&gt;test&lt;/code&gt;的项目需要管理，那么首先我们需要在Git服务器上面创建并初始化该项目。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ sudo su git
$ cd
$ mkdir test
$ cd test
$ git init --bare
Initialized empty Git repository in /home/git/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，其中&lt;code&gt;git init --bare&lt;/code&gt;就是用来初始化Git项目的，&lt;code&gt;--bare&lt;/code&gt;参数表示只存储Git的管理文件而不展现&lt;code&gt;test&lt;/code&gt;项目本身的文件。查看下初始化之后的目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ls
branches  config  description  HEAD  hooks  info  objects  refs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见里面只有Git管理有关的文件。&lt;/p&gt;

&lt;h2 id=&#34;上传-test-项目&#34;&gt;上传&lt;code&gt;test&lt;/code&gt;项目&lt;/h2&gt;

&lt;p&gt;假定Git服务器IP为&lt;code&gt;10.10.10.10&lt;/code&gt;，回到你的工作机器，打开&lt;code&gt;test&lt;/code&gt;项目目录，上传项目：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cd test
$ git remote add origin git@10.10.10.10:/home/git/mlc
$ git remote -v
origin  git@10.10.10.10:/home/git/mlc (fetch)
origin  git@10.10.10.10:/home/git/mlc (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果发现&lt;code&gt;git remote add origin&lt;/code&gt;执行失败：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote add origin git@10.10.10.10:/home/git/mlc
fatal: remote origin already exists.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明曾经已经设置过&lt;code&gt;origin&lt;/code&gt;地址了，可以更改如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote remove origin
$ git remote -v
$ git remote add origin git@10.10.10.10:/home/git/mlc
$ git remote -v
origin  git@10.10.10.10:/home/git/mlc (fetch)
origin  git@10.10.10.10:/home/git/mlc (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置好之后，可以上传&lt;code&gt;test&lt;/code&gt;项目了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git push origin master
git@10.10.10.10&#39;s password:
Counting objects: 4, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 531 bytes | 0 bytes/s, done.
Total 4 (delta 0), reused 0 (delta 0)
To 10.10.10.10:/home/git/mlc
 * [new branch]      master -&amp;gt; master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，Git服务器已经可以正常工作了。&lt;/p&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;本文只是简单的介绍原生的Git服务器的搭建，实际上，在现实工作中很多情况下都会有专门的基于Git的管理系统，使用起来非常方便。这里面非开源的最有名当然是&lt;code&gt;Github&lt;/code&gt;了，开源的里面目前最好的应该是&lt;code&gt;Gitlab&lt;/code&gt;了，参照官方文档，你可以非常方便的搭建自己的Git服务器了。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server&#34;&gt;Git on the Server - Setting Up the Server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux学习从入门到精通推荐书籍</title>
      <link>https://keysaim.github.io/post/linux/2017-08-18-linux-learning-materials/</link>
      <pubDate>Fri, 18 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-08-18-linux-learning-materials/</guid>
      
        <description>

&lt;h1 id=&#34;如何学习linux&#34;&gt;如何学习Linux&lt;/h1&gt;

&lt;p&gt;在现在的生活，生产，研究等领域，Linux已经无所不在，从我们使用的手机，车载设备，到服务器，桌面电脑等，Linux已经成为这个世界方方面面的基石。尤其对于参与技术有关工作的你学习Linux是必须的，那么，该如何有效的学习呢？Linux从诞生至今，已经是一个非常庞大且复杂的系统，下图是Linux系统代码行数的统计（参考&lt;a href=&#34;https://www.linuxcounter.net/statistics/kernel&#34;&gt;linuxcounter&lt;/a&gt;）：
&lt;img src=&#34;https://keysaim.github.io/img/blog-linux-code-lines.png&#34; alt=&#34;Linux代码行数变化&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可见截止本文为止，Linux的代码行数逼近2千万行，你就每天看1万行也得要6，7年，况且这还只是Linux内核的代码量，再加上每个Linux发行版本有关的代码，估计得突破天际了。因此，要在短期内全面的学习Linux的方方面面对于一个正常的人来说几乎不太可能。所以，学习Linux的关键便在于对于学习Linux的目的一定要明确，通常来讲可能会涉及到一下方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;了解及入门&lt;/li&gt;
&lt;li&gt;成为Linux的系统管理员&lt;/li&gt;
&lt;li&gt;学习Linux应用编程&lt;/li&gt;
&lt;li&gt;学习Linux内核开发&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，这只是其中几个大的方面，即便如此，其中每个方面都是一个非常大的议题。比如说&lt;code&gt;学习Linux内核开发&lt;/code&gt;，这个就包括了无数小的方面，内核本身就包括了非常多的细分方向，比如有的搞网络，有的搞文件系统，有的搞驱动开发等等。所以，对于Linux，还请千万慎重的评价自己是否真的&lt;code&gt;精通&lt;/code&gt;，学无止境，真要&lt;code&gt;精通&lt;/code&gt;Linux的主要方面，有可能需要穷尽你的个人生涯。&lt;/p&gt;

&lt;p&gt;当然，对于学习Linux，前人已经铺好了无数的基石，有无数可以参考学习的资料，而且内核也是开源的，必要的时候可以查看&lt;a href=&#34;https://github.com/torvalds/linux&#34;&gt;其代码&lt;/a&gt;，甚至已经有非常多帮你分析内核代码的&lt;a href=&#34;https://www.quora.com/What-are-the-best-resources-to-learn-about-Linux-kernel-internals&#34;&gt;书籍资料&lt;/a&gt;，甚至还有很多&lt;a href=&#34;https://www.zhihu.com/question/19606660&#34;&gt;中文资料&lt;/a&gt;。所以，不论你打算要学习到如何的程度，已经有无数的资料可以参考，也有极为庞大的&lt;a href=&#34;http://www.linuxandubuntu.com/home/top-10-communities-to-help-you-learn-linux&#34;&gt;社区&lt;/a&gt;可以依靠。本文将就Linux学习推荐一些经典免费的书籍，主要侧重覆盖从入门到成为系统管理员的有关方面，学习对象为初学Linux，以及需要重新系统学习Linux的读者，将涵盖以下方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;入门基础&lt;/li&gt;
&lt;li&gt;Linux命令行及工具&lt;/li&gt;
&lt;li&gt;Linux Bash脚本&lt;/li&gt;
&lt;li&gt;Linux发行版本&lt;/li&gt;
&lt;li&gt;Linux系统管理&lt;/li&gt;
&lt;li&gt;Linux基本开发&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;为啥需要重点学习系统管理方面呢？有的Linux开发人员可能会说，不是有专门的Linux系统管理员吗，有必要花大力气学习系统管理吗？这个博主表示是非常有必要，开发可能侧重于功能的实现，而且往往侧重于细节，然而系统管理则直接面向功能本身，更多的是从整个系统的宏观角度来熟悉Linux。咱们有句话说&lt;code&gt;不识庐山真面目，只缘身在此山中&lt;/code&gt;便是这个道理，开发者对于细节或许极为了解，但是未必对整个系统功能有足够的熟悉。而如果对于宏观的系统整体有足够的理解，对于开发本身来说也是有很大的促进作用的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;书籍推荐&#34;&gt;书籍推荐&lt;/h1&gt;

&lt;h2 id=&#34;入门基础书籍&#34;&gt;入门基础书籍&lt;/h2&gt;

&lt;h3 id=&#34;introduction-to-linux&#34;&gt;Introduction to Linux&lt;/h3&gt;

&lt;p&gt;这是一本免费的书，来自于&lt;a href=&#34;Linux_Doc_Proj&#34;&gt;Linux文档项目&lt;/a&gt;。虽然免费，但是不影响它的流行程度，该书比较系统的介绍了Linux的一些基本概念，包括文件系统，命令行，网络等。但是鉴于Linux现在也是版本帝，有些内容可能跟不上最新的版本，但是，这完全不影响对于基本概念的理解。&lt;/p&gt;

&lt;h3 id=&#34;linux-fundamentals&#34;&gt;Linux Fundamentals&lt;/h3&gt;

&lt;p&gt;从这本书的书名就可以看出，作者&lt;a href=&#34;http://www.linkedin.com/in/cobbaut&#34;&gt;Paul Cobbaut&lt;/a&gt;就是侧重于介绍Linux最基础的有关知识。涉及到Linux的历史，如何安装以及一些简单但是常用的命令。&lt;/p&gt;

&lt;h2 id=&#34;linux命令行及工具书籍&#34;&gt;Linux命令行及工具书籍&lt;/h2&gt;

&lt;h3 id=&#34;gnu-linux-command-line-tools-summary&#34;&gt;GNU/Linux Command−Line Tools Summary&lt;/h3&gt;

&lt;p&gt;这本书同样来自于&lt;a href=&#34;Linux_Doc_Proj&#34;&gt;Linux文档项目&lt;/a&gt;。适于初学Linux命令行的读者。&lt;/p&gt;

&lt;h3 id=&#34;bash-reference-manual-from-gnu&#34;&gt;Bash Reference Manual from GNU&lt;/h3&gt;

&lt;p&gt;此书来自于&lt;a href=&#34;https://www.gnu.org/home.en.html&#34;&gt;GNU&lt;/a&gt;，着重介绍Linux命令行。&lt;/p&gt;

&lt;h3 id=&#34;the-linux-command-line&#34;&gt;The Linux Command Line&lt;/h3&gt;

&lt;p&gt;如果你把前面的几本基本的命令行的书籍啃完，并迫切希望能够进一步深入了解命令行，那么这本出自&lt;a href=&#34;http://www.oreilly.com/pub/au/4962&#34;&gt;William Shotts&lt;/a&gt;的书是必须一读的，此书500多页的篇幅，极为详尽的介绍了Linux命令行，也许你自诩比较熟悉命令行，相信此书还是能够带个你新的见识。&lt;/p&gt;

&lt;h2 id=&#34;linux-bash脚本书籍&#34;&gt;Linux Bash脚本书籍&lt;/h2&gt;

&lt;h3 id=&#34;bash-beginners-guide&#34;&gt;Bash Beginners Guide&lt;/h3&gt;

&lt;p&gt;顾名思义，此书就是为初学者准备的，同样来自于&lt;a href=&#34;Linux_Doc_Proj&#34;&gt;Linux文档项目&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;advanced-bash-scripting-guide&#34;&gt;Advanced Bash-Scripting Guide&lt;/h3&gt;

&lt;p&gt;如果你对Linux Bash脚本有了基本的认识，那么这本书将是你进阶的必备书籍。此书900多页的篇幅涉及Bash脚本的方方面面，不论对于打算进阶或者已经较为熟悉的人来说都是一本重要的参考书籍。&lt;/p&gt;

&lt;h3 id=&#34;the-awk-programming-language&#34;&gt;The AWK Programming Language&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.tutorialspoint.com/unix_commands/awk.htm&#34;&gt;AWK&lt;/a&gt;命令是一个极为强大的Linux命令，同时提供非常强大的脚本支持。也正是因为强大，所以就有专门的书籍来介绍这个命令，如果你要把自己的Linux命令再提升一点的话，建议看下这本书来深入的学习该命令。&lt;/p&gt;

&lt;h3 id=&#34;linux-101-hacks&#34;&gt;Linux 101 Hacks&lt;/h3&gt;

&lt;p&gt;不论从这本书的书名，还是这本书的来源&lt;a href=&#34;http://www.thegeekstuff.com/2009/02/linux-101-hacks-download-free-ebook/&#34;&gt;The Geek Stuff&lt;/a&gt;，此书都暗示着其将以新颖独特的角度为你介绍Linux脚本。&lt;/p&gt;

&lt;h2 id=&#34;linux发行版本书籍&#34;&gt;Linux发行版本书籍&lt;/h2&gt;

&lt;h3 id=&#34;centos-system-administration-essentials&#34;&gt;CentOS System Administration Essentials&lt;/h3&gt;

&lt;p&gt;这本书较为系统的介绍了Centos系统的有关知识，包括了文件系统，包管理系统，用户系统，安全中心以及一些常用应用软件介绍，对于使用Centos系统的人员还是有所帮助的。&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-manual&#34;&gt;Ubuntu Manual&lt;/h3&gt;

&lt;p&gt;这本书来源于&lt;a href=&#34;https://ubuntu-manual.org/&#34;&gt;Ubuntu Manual网站&lt;/a&gt;，以不多的篇幅较为系统的介绍了Ubuntu系统的日常使用。&lt;/p&gt;

&lt;h3 id=&#34;for-linux-mint-just-tell-me-damnit&#34;&gt;For Linux Mint: Just Tell Me Damnit!&lt;/h3&gt;

&lt;p&gt;这本书集中介绍了&lt;a href=&#34;https://www.linuxmint.com/&#34;&gt;Linux Mint&lt;/a&gt;系统，涉及了安装，包管理，定制桌面等方面。&lt;/p&gt;

&lt;h3 id=&#34;solus-linux-manual&#34;&gt;Solus Linux Manual&lt;/h3&gt;

&lt;p&gt;顾名思义，此书介绍&lt;a href=&#34;https://solus-project.com/&#34;&gt;Solus Linux&lt;/a&gt;系统，篇幅较短。&lt;/p&gt;

&lt;h3 id=&#34;the-debian-administration-s-handbook&#34;&gt;The Debian Administration’s Handbook&lt;/h3&gt;

&lt;p&gt;这本书号称&lt;a href=&#34;https://www.debian.org/&#34;&gt;Debian Linux&lt;/a&gt;系统的圣经，涵盖了Debian的历史，安装，包管理，虚拟机，存储等方面，对于使用Debian系统的人员来说，此书必备。&lt;/p&gt;

&lt;h2 id=&#34;linux系统管理书籍&#34;&gt;Linux系统管理书籍&lt;/h2&gt;

&lt;p&gt;虽然此章节被独立命名为&lt;code&gt;Linux系统管理&lt;/code&gt;，但是，前面的章节其实都可以认为在此范畴，只不过更加偏向于基础。所以，在这章节中都是侧重于较为深入的系统管理有关知识，最好是在前面章节的基础之上再学习此章节。&lt;/p&gt;

&lt;h3 id=&#34;linux-system-administration&#34;&gt;Linux System Administration&lt;/h3&gt;

&lt;p&gt;这本书也是出自于&lt;a href=&#34;http://www.linkedin.com/in/cobbaut&#34;&gt;Paul Cobbaut&lt;/a&gt;之手，覆盖了网络，磁盘，用户，内核，库等管理。&lt;/p&gt;

&lt;h3 id=&#34;advanced-linux-system-administration&#34;&gt;Advanced Linux System Administration&lt;/h3&gt;

&lt;p&gt;如果你觉得自己很懂Linux系统管理，也非常希望别人能够知道你很懂，那么你应该去参加&lt;a href=&#34;LPIC&#34;&gt;LPIC&lt;/a&gt;。而要参加该认证，此书是必看的官方指定用书。&lt;/p&gt;

&lt;h3 id=&#34;pro-linux-system-administration-2nd-edition&#34;&gt;Pro Linux System Administration, 2nd Edition&lt;/h3&gt;

&lt;p&gt;这是一本非常详细的Linux系统管理的书籍，全书1000+页的篇幅涵盖了Linux系统管理的很多方面，即适合初学者，也可以作为有一定基础的人系统学习的重要参考。同时，该书的第二部分介绍了很多Linux系统管理的应用，如NTP，DNS，邮件，文件共享，性能监控等等，非常值得一看。&lt;/p&gt;

&lt;h3 id=&#34;linux-bible-9th-edition&#34;&gt;Linux Bible 9th Edition&lt;/h3&gt;

&lt;p&gt;不用讲了，敢取这么牛逼的名字，而且书的&lt;a href=&#34;https://www.amazon.com/Linux-Bible-Christopher-Negus/dp/1118999878&#34;&gt;评价还不错&lt;/a&gt;，必然是好书。此书将近1000页的篇幅，从不同程度介绍了Linux系统，比如如何入门，如何成为Linux的熟练用户，如果成为系统管理员，如何成为Linux安全维护人员等等，还是比较实至名归的。&lt;/p&gt;

&lt;h3 id=&#34;linux-servers&#34;&gt;Linux Servers&lt;/h3&gt;

&lt;p&gt;此书又来自于&lt;a href=&#34;http://www.linkedin.com/in/cobbaut&#34;&gt;Paul Cobbaut&lt;/a&gt;，从书名就能推测其范畴，主要侧重讲述如何打造你的Linux服务器，包括web server，mysql数据库，DHCP等。&lt;/p&gt;

&lt;h3 id=&#34;linux-networking&#34;&gt;Linux Networking&lt;/h3&gt;

&lt;p&gt;Linux网络对于系统管理员来说是最为重要的一块之一，同样出自于&lt;code&gt;Paul Cobbaut&lt;/code&gt;之手，较为系统的介绍了Linux网络基础知识，网络配置，同时着重介绍了常用的网络服务等。&lt;/p&gt;

&lt;h3 id=&#34;linux-storage&#34;&gt;Linux Storage&lt;/h3&gt;

&lt;p&gt;此书作者估计你都能猜到了，不错，又是&lt;code&gt;Paul Cobbaut&lt;/code&gt;。该书同样较为系统的介绍了Linux的存储系统，涉及文件管理，磁盘管理，数据库等方面。&lt;/p&gt;

&lt;h3 id=&#34;linux-security&#34;&gt;Linux Security&lt;/h3&gt;

&lt;p&gt;作者就不介绍了，你懂的。很多时候对于Linux系统都更侧重于功能方面，对于安全方面往往做的不够。然而现在网络安全正面临越来越严峻的挑战，由网络安全带来的损失也是越来越大，因此，对于Linux的安全管理已经成为系统管理最为重要的一部分。此书同样系统的介绍了Linux的安全管理有关方面，涉及用户/组安全，文件安全，iptables防火墙，selinux安全等方面。&lt;/p&gt;

&lt;h2 id=&#34;linux基本开发书籍&#34;&gt;Linux基本开发书籍&lt;/h2&gt;

&lt;p&gt;最后，稍微推荐一下Linux开发有关的书籍。&lt;/p&gt;

&lt;h3 id=&#34;advanced-linux-programming&#34;&gt;Advanced Linux Programming&lt;/h3&gt;

&lt;p&gt;此书面向致力于Linux软件开发人员，介绍了Linux多进程，多线程，进程间通信，以及硬件接口等方面，对于从事有关开发工作还是很有帮助的。&lt;/p&gt;

&lt;h1 id=&#34;书籍下载&#34;&gt;书籍下载&lt;/h1&gt;

&lt;p&gt;本博文中所列书籍都可以在博主的&lt;a href=&#34;http://download.csdn.net/user/walkerhau&#34;&gt;CSDN个人下载空间&lt;/a&gt;找到，资源名为&lt;code&gt;Linux入门及系统管理推荐书籍&lt;/code&gt;，由于大小限制，分为三个压缩包，下载所有压缩包到一台Linux机器，解压运行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat linux-basic.tgz.* | tar xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中有一个文件整理的时候出错了，文件名为&lt;code&gt;Ubuntu-Manual.pdf&lt;/code&gt;，其实是&lt;code&gt;Solus&lt;/code&gt;的电子书。你可以从&lt;a href=&#34;https://ubuntu-manual.org/&#34;&gt;Ubuntu Manual官网&lt;/a&gt;直接下载。&lt;/p&gt;

&lt;p&gt;资源需要一定的资源分下载，本来想免费，但是博主个人觉得还是不错的资源，也废了自己不少时间整理，鉴于免费容易轻视，所以面向真要打算认真学习的人，收取一定的资源分。如果没有足够的资源分也没关系，你完全可以根据本文所列书名Google之，都是有免费电子版的。实在不愿自己搜罗的，也可以在评论区留下你的邮箱，博主会不定时发给你邮箱，压缩包总共将近140M，还请确保你的邮箱能够接收如此大的附件。&lt;/p&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;Linux博大精深，很多人即便从事一辈子Linux开发也未必能够熟悉Linux的各个方面。为了能够支撑自己在Linux的路上走的足够远，一个牢固的基础是必须得有的，本文侧重推荐Linux系统管理的有关书籍，希望读者能够对Linux的宏观整体有个非常透彻的理解，为以后选择某个方向深入研究铺好路。同时，也欢迎各位的其它推荐，欢迎在评论区留言，有合适的书籍，博主也会不定时更新在博文之中。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;Linux_Doc_Proj&#34;&gt;Linux Document Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ubuntu-manual.org/&#34;&gt;Ubuntu Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;LPIC&#34;&gt;LPIC wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itsfoss.com/learn-linux-for-free/&#34;&gt;learn linux for free&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>如何给自己的博客网站加入评论系统</title>
      <link>https://keysaim.github.io/post/blog/2017-08-16-how-to-add-comments/</link>
      <pubDate>Wed, 16 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/blog/2017-08-16-how-to-add-comments/</guid>
      
        <description>

&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;在&lt;a href=&#34;https://keysaim.github.io/2017/08/15/how-to-setup-your-github-io-blog/&#34;&gt;这一篇&lt;/a&gt;博文中，咱们介绍了如何快速的搭建个人的博客网站，但是这个博客网站是基于&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;的纯静态网站，自身是不带任何的可交互的元素的，自然也就没有评论系统。但是，对于一个好的博客网站，如果没有评论系统，那基本上就属于自娱自乐了，也违背了博客分享的精神。因此，本文将着重介绍如何快速的给自己的博客网站加入评论系统。&lt;/p&gt;

&lt;h1 id=&#34;评论系统介绍&#34;&gt;评论系统介绍&lt;/h1&gt;

&lt;p&gt;所谓评论系统，相信对于关注博客的你来说肯定不陌生。通常来讲有两大类，一类是网站自己提供评论系统，这个在很多较大的博客平台比较常见；一类是基于第三方的评论系统，这个在个人博客网站较为常见。对于个人博客，由于很多都是简单的托管在其他平台上面，比如博主网站托管于Github，因此很多都基本上是静态的网站，自身是没法提供评论系统。也正因为如此，也就催生了非常多的第三方的评论系统。这些系统国外比较有名的是&lt;a href=&#34;https://disqus.com/&#34;&gt;Disqus&lt;/a&gt;，国内更加五花八门了。国外的由于天朝特殊的网络环境，并不十分稳定，所以对于国内的博客网站来说，通常都会选择国内的第三方评论系统。至于国内的评论系统有哪些选择呢，建议参考&lt;a href=&#34;https://www.mokeyjay.com/archives/1732&#34;&gt;这篇博文&lt;/a&gt;。总的来说，由于评论系统这个东东，目前还没有明显的盈利的地方，倒闭关门是很有可能的，因此尽量选择大公司为后台的吧。&lt;/p&gt;

&lt;p&gt;最近在研究评论系统的时候，偶然发现&lt;a href=&#34;http://hydroecology.net/using-github-to-host-blog-comments/&#34;&gt;有人&lt;/a&gt;居然直接使用Github的Issue系统来做评价系统，顿时眼前一亮啊。鉴于咱们的博客便是基于Github的，如果可行，那简直绝配了。于是博主就开始疯狂的搜索有关现状，Github都多少年了，博主深信应该已经有人造过轮子了。这类轮子肯定是属于前端方面的，于是在&lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;网站上面搜索，果然&lt;a href=&#34;https://www.npmjs.com/search?q=github%20issue%20comment&amp;amp;page=1&amp;amp;ranking=popularity&#34;&gt;发现不少&lt;/a&gt;。比较下来，发现一款国人开发的&lt;a href=&#34;https://www.npmjs.com/package/gitment&#34;&gt;gitment&lt;/a&gt;最为完整。这也就本文要介绍的评论系统了，本博客网站在可见的未来将采用该评论系统，这里对作者的分享表示感谢。&lt;/p&gt;

&lt;h1 id=&#34;gitment使用&#34;&gt;gitment使用&lt;/h1&gt;

&lt;p&gt;gitment的使用在&lt;a href=&#34;https://imsun.net/posts/gitment-introduction/&#34;&gt;官网&lt;/a&gt;有较为详细的介绍，步骤写的还是比较清楚的。这里只是对于讲述可能踩到的坑：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;请务必不要使用你的&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;这个repo作为&lt;code&gt;gitment&lt;/code&gt;的repo&lt;/p&gt;

&lt;p&gt;可能这个repo作为Github特殊的repo，使用它作为&lt;code&gt;gitment&lt;/code&gt;的repo时，总是不能够认证成功。建议再创建一个专门用来存放评论的repo。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/settings/applications/new&#34;&gt;生成oauth授权&lt;/a&gt;的时候，请务必确保&lt;code&gt;Authorization callback URL&lt;/code&gt;是你的博客网站，如博主的是&lt;code&gt;https://keysaim.github.io&lt;/code&gt;。否则会授权失败。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每次提交博文的时候，请务必记得初始化改博文的评论，否则读者无法进行评论&lt;/p&gt;

&lt;p&gt;所谓初始化其实就是在你的博文下面用自己的Github账号登陆之后，会出现一个&lt;code&gt;Initialize Comments&lt;/code&gt;字样的按钮，点击该按钮完成初始化。改初始化其实就是在你的Github repo里面针对这篇博文生成一个新的Issue。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;gitment&lt;/code&gt;之类的评论系统是基于Github的Issue系统，每篇博文都对应于你的Github repo里面的一个Issue，博文里面的评论其实都是在改Issue里面的评论，因此，你是有绝对权限对所有评论进行管理的。另外，由于&lt;code&gt;gitment&lt;/code&gt;项目开始不久，并且貌似作者比较忙，因此功能性，质量方面还是存在不足，当你使用过程中如果遇到任何问题，可以直接去&lt;a href=&#34;https://github.com/imsun/gitment&#34;&gt;gitment repo&lt;/a&gt;里面查看一下是不是别人也碰到类似问题。可能的情况下，你也可以提交自己的解决方案。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>如何使用特定的SSH Key提交GIT</title>
      <link>https://keysaim.github.io/post/git/2017-08-15-how-to-git-with-specific-ssh-key/</link>
      <pubDate>Tue, 15 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/git/2017-08-15-how-to-git-with-specific-ssh-key/</guid>
      
        <description>

&lt;h1 id=&#34;问题提出&#34;&gt;问题提出&lt;/h1&gt;

&lt;p&gt;最近在自己的MAC上面提交&lt;code&gt;Github&lt;/code&gt;代码的时候发现居然失败了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git push origin master
Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不是坑爹吗，&lt;code&gt;Github&lt;/code&gt;都提交过无数次了，咋就失败了呢？莫非&lt;code&gt;Github&lt;/code&gt;上的ssh key被删掉了么。于是打开&lt;a href=&#34;https://github.com/settings/keys&#34;&gt;github ssh&lt;/a&gt;，尝试再次把ssh key加上，却提示key已经存在了。于是赶紧回到本地repo查看下用户是不是对的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git config -l
...
user.email=keysaim@gmail.com
user.name=keysaim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再查看下本地的ssh key：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCu4Jy/+uFGiC89luBejzCEyPbY0SRoppyzrB4g1v3zv1OleylMzdf+eTTRcYgMbYoY6ZQs4M2NHX20iO6vf6j2uPvUsB++pP0G6Q7+VlrUlC19B07IVx7Mo2xmHCe4bMshFSugqOl+hV6zVjGpYJcLI9XtWQ6F/br4tkYD/J8KWns+SNha8gJVBckV1ncGlR+Q7ji4OM4+eIhKEEK4Wo7Cf7KaT71fIVFl7XRx5kmdtEN3F+wT4LjNb2okl8Pu4mmxCMwJvXzj0Jr9PkVzhSAhDkWG3mMt3kC5PhhRhCP7uwkGFsOEm5uGS907wTxY9cJNIl8FikOfmvDa5XrfMbMx nbaoping@xxx.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现邮件居然是&lt;code&gt;nbaoping@xxx.com&lt;/code&gt;（此处已打码），显然跟本地repo的&lt;code&gt;keysaim@gmail.com&lt;/code&gt;不同，&lt;code&gt;git&lt;/code&gt;提交的时候没有特殊配置，会使用默认的ssh key，也就是&lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt;，而提交的用户信息跟此key并不能对应上，故此&lt;code&gt;github&lt;/code&gt;拒绝了此次提交。既然如此，那把本地repo的用户信息改成key所对应的信息不就好了吗？是的，但是此信息都已经打码了就充分说明本博主是十分不愿暴露它的，咱必须得想其它辙。&lt;/p&gt;

&lt;p&gt;好了，现在的问题就是，如何使用特定的ssh key提交Git？本文就来讲述一种通用的解决办法。&lt;/p&gt;

&lt;h1 id=&#34;指定-git-提交使用的ssh-key&#34;&gt;指定&lt;code&gt;git&lt;/code&gt;提交使用的ssh key&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看repo对应的hostname&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote -v
origin  git@github.com:keysaim/keysaim.github.io.git (fetch)
origin  git@github.com:keysaim/keysaim.github.io.git (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;github.com&lt;/code&gt;就是repo使用的&lt;code&gt;hostname&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看repo的用户信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git config -l
...
user.email=keysaim@gmail.com
user.name=keysaim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最关键的是邮件信息&lt;code&gt;keysaim@gmail.com&lt;/code&gt;。如果没有用户信息，可以先配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git config user.email &amp;quot;keysaim@gmail.com&amp;quot;
$ git config user.name &amp;quot;keysaim&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，很多教程里面以及&lt;code&gt;git&lt;/code&gt;的错误提示里面会建议在&lt;code&gt;git config&lt;/code&gt;后面加入参数&lt;code&gt;git config --global&lt;/code&gt;，这里，千万不要加入此参数，否则它会去尝试修改你的&lt;code&gt;git&lt;/code&gt;的全局配置，也就是你所有repo默认的用户信息。你可以在文件&lt;code&gt;~/.git/config&lt;/code&gt;查看你的全局配置，其中&lt;code&gt;[user]&lt;/code&gt;段就是你的默认用户信息。咱们这里就是为了能够给这个repo指定特定的ssh key，显然不适合使用全局的配置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为repo的用户生成新的ssh key&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ssh-keygen -C &amp;quot;keysaim@gmail.com&amp;quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/nbaoping/.ssh/id_rsa): id_rsa.github
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in id_rsa.github.
Your public key has been saved in id_rsa.github.pub.
The key fingerprint is:
SHA256:G0djI0bh+XwGcwOZ0AsbQ8ffB51pYrfSlRALNZw3igc keysaim@gmail.com
The key&#39;s randomart image is:
+---[RSA 2048]----+
|       .==o+o=+.+|
|       o+o=E.=+Oo|
|        ==Bo*oB.+|
|       ..*.B.=.o.|
|        S + + .. |
|         + o     |
|        .        |
|                 |
|                 |
+----[SHA256]-----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;-C&lt;/code&gt;是用来指定该key的用户信息的，这里咱们使用了&lt;code&gt;keysaim@gmail.com&lt;/code&gt;。该命令是一个交互式的命令，其中大部分你都可以直接回车，但是对于第一个提示&lt;code&gt;Enter file in which to save the key&lt;/code&gt;，&lt;strong&gt;&lt;em&gt;请务必输入你想要的文件名，否则它将覆盖你默认的ssh key，这个可是不可逆的&lt;/em&gt;&lt;/strong&gt;。这里使用文件名&lt;code&gt;id_rsa.github&lt;/code&gt;。如果没有指定文件夹在路径中，该命令会在当前目录下生成key文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ls id_rsa.github*
id_rsa.github  id_rsa.github.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;id_rsa.github&lt;/code&gt;是私钥，而&lt;code&gt;id_rsa.github.pub&lt;/code&gt;为公钥。将key文件移到ssh目录下&lt;code&gt;~/.ssh/&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ mv id_rsa.github* ~/.ssh/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置ssh以使用新的key&lt;/p&gt;

&lt;p&gt;修改ssh的配置文件&lt;code&gt;~/.ssh/config&lt;/code&gt;，加入如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host github.com
    HostName github.com
    User git
    IdentityFile /Users/nbaoping/.ssh/id_rsa.github
    IdentitiesOnly yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面逐行解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Host github.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用来指定该key的Host名字，此处必须使用本地repo的hostname &lt;code&gt;github.com&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Hostname github.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此处指定&lt;code&gt;Host&lt;/code&gt;对应的具体域名，这里跟&lt;code&gt;Host&lt;/code&gt;保持一致。（&lt;code&gt;Host&lt;/code&gt;跟&lt;code&gt;Hostname&lt;/code&gt;可以不一致，但是&lt;code&gt;Host&lt;/code&gt;必须跟repo的hostname保持一致，也就是git到时候会用自己repo的hostname来ssh配置文件里面找是不是有对应的&lt;code&gt;Host&lt;/code&gt;，找到了就使用该配置，具体访问的域名会采用&lt;code&gt;HostName&lt;/code&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;User git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;说明该配置的用户得是git&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;IdentityFile /Users/nbaoping/.ssh/id_rsa.github&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这行最为关键，指定了该使用哪个ssh key文件，这里的key文件一定指的是私钥文件。之前我们生成了新的私钥文件&lt;code&gt;~/.ssh/id_rsa.github&lt;/code&gt;，由于博主使用的是MAC，&lt;code&gt;~&lt;/code&gt;被翻译成&lt;code&gt;/Users/nbaoping/&lt;/code&gt;了，如果是在一般的Linux环境下，改路径前缀该是&lt;code&gt;/home/nbaoping/&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;IdentitiesOnly yes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;请配置为&lt;code&gt;yes&lt;/code&gt;，具体意义可以&lt;a href=&#34;https://serverfault.com/questions/450796/how-could-i-stop-ssh-offering-a-wrong-key/450807#450807&#34;&gt;参考讨论&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将生成的ssh key加入&lt;code&gt;github&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开&lt;a href=&#34;https://github.com/settings/keys&#34;&gt;github ssh key&lt;/a&gt;配置页面，点击&lt;code&gt;New SSH Key&lt;/code&gt;，给刚刚生成的key取名，如&lt;code&gt;keysaim-mac&lt;/code&gt;。把&lt;code&gt;~/.ssh/id_rsa.github.pub&lt;/code&gt;（请务必注意是公钥文件，千万不要搞错了）里面的内容拷贝过来，点击&lt;code&gt;Add SSH Key&lt;/code&gt;按钮保持。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交&lt;/p&gt;

&lt;p&gt;做完上面的步骤之后，就可以提交了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git push origin master
Counting objects: 63, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (62/62), done.
Writing objects: 100% (63/63), 838.96 KiB | 0 bytes/s, done.
Total 63 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), done.
To github.com:keysaim/keysaim.github.io.git
   73a2043..88cacc1  master -&amp;gt; master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，这次提交成功了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;当你需要把某些repo以不同的用户提交的时候，可以按照本文给他们配置特殊的ssh key，但是注意的一点就是，这种配置事基于&lt;code&gt;Host&lt;/code&gt;，也就是repo的hostname，如果需要确保不同的repo使用不同的ssh key，需要每个repo使用不同的hostname。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain&#34;&gt;Specify an SSH key for git push for a given domain&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>如何快速搭建自己的github.io博客</title>
      <link>https://keysaim.github.io/post/blog/2017-08-15-how-to-setup-your-github-io-blog/</link>
      <pubDate>Tue, 15 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/blog/2017-08-15-how-to-setup-your-github-io-blog/</guid>
      
        <description>

&lt;h1 id=&#34;闲聊一下&#34;&gt;闲聊一下&lt;/h1&gt;

&lt;p&gt;在这知识剧烈膨胀的时代，如何记录、整理、分享自己的所学所感无疑显得十分重要，而博客便是最好的方式之一。现在已经有了各式各样的博客平台，有基于第三方的平台的（如&lt;a href=&#34;https://www.cnblogs.com/&#34;&gt;博客园&lt;/a&gt;等），也有自己搭建的（如基于&lt;a href=&#34;https://ghost.org/&#34;&gt;Ghost&lt;/a&gt;等，当然，也有很多干脆自己动手DIY了）。总之，博客的世界已然丰富多彩，留给咱们更多的不是有没有，而是哪个好。这里咱不讨论博客哪家强的问题，只推荐一款博主觉得不错的选择：&lt;code&gt;github.io&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;要问全球最大的基佬交友网站是哪个，我相信不少答案必须是咱们的&lt;a href=&#34;https://github.com&#34;&gt;github&lt;/a&gt;。而&lt;code&gt;github.io&lt;/code&gt;便是其出品，品质必须是有保证的，最重要的一点是基于github的repo管理，这意味着咱们对其是有觉得的控制，这个跟放在第三方的平台比，可控性要好太多。下面咱们将详细讲述如何基于&lt;code&gt;github.io&lt;/code&gt;打造属于自己的博客网站。&lt;/p&gt;

&lt;p&gt;要完成自己的&lt;code&gt;github.io&lt;/code&gt;博客网站，总共分三步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开通自己的&lt;code&gt;github.io&lt;/code&gt; repo&lt;/li&gt;
&lt;li&gt;选择一款Jekyll的主题&lt;/li&gt;
&lt;li&gt;编写发布博客&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;开通自己的-github-io-repo&#34;&gt;开通自己的&lt;code&gt;github.io&lt;/code&gt; repo&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;github.io&lt;/code&gt;是完全基于github创建的，其本质上是在你的github账户下创建一个特殊的repo。你可以参照&lt;a href=&#34;https://pages.github.com/&#34;&gt;如下步骤&lt;/a&gt;完成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建repo&lt;/p&gt;

&lt;p&gt;当然，一切的前提是你得首先有个github的账户，这里还请自行解决。登陆你的账户后，你可以&lt;a href=&#34;https://github.com/new&#34;&gt;创建一个新的repo&lt;/a&gt;。&lt;strong&gt;&lt;em&gt;请务必注意该repo的名字，必须保持格式&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;，其中&lt;code&gt;&amp;lt;username&amp;gt;&lt;/code&gt;替换成你的github账户名&lt;/em&gt;&lt;/strong&gt;，这里假定创建的repo为&lt;code&gt;tobiasalin.github.io&lt;/code&gt;&lt;/p&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
    &lt;img src=&#34;https://pages.github.com/images/user-repo@2x.png&#34; alt=&#34;&#34;/&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把你创建的repo clone到本地&lt;/p&gt;

&lt;p&gt;本文假定你已经有一定的&lt;code&gt;git&lt;/code&gt;使用基础了，如果没有也没关系，Google一下，&lt;code&gt;git&lt;/code&gt;的基本使用极为简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/tobiasalin/tobiasalin.github.io
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编写简单的博客首页&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd tobiasalin.github.io
$ echo &amp;quot;Hello World!&amp;quot; &amp;gt; index.html
$ git add index.html
$ git commit -m &amp;quot;Init commit&amp;quot;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开博客网站&lt;code&gt;https://&amp;lt;username&amp;gt;.github.io&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不出意外，你就可以看到你的&lt;code&gt;Hello World!&lt;/code&gt;博客首页了。如果不小心出了意外，通常情况下，你只需等一会再刷新就会好，要是还没好，通常说明你的运气实在太背，请自行了断。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;选择一款-jekyll-的主题&#34;&gt;选择一款&lt;code&gt;Jekyll&lt;/code&gt;的主题&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;github.io&lt;/code&gt;默认采用&lt;code&gt;Jekyll&lt;/code&gt;作为建站工具。&lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt;是一款当前火热的开源的静态网站建站工具，拥有非常庞大的使用群里和社区，其&lt;a href=&#34;https://github.com/jekyll/jekyll&#34;&gt;Github&lt;/a&gt;截止本文，已经有超过3W+的star，拥有丰富的插件，丰富的主题，并且有无数的人已经帮你早出了无数的轮子可供参考。&lt;code&gt;Jekyll&lt;/code&gt;自身的强大功能已经足够你打造自己心仪的静态网站（这里注意的是&lt;code&gt;静态网站&lt;/code&gt;，&lt;code&gt;Jekyll&lt;/code&gt;没有任何的后台数据库），然而前提是你自己还是得有一定的前端功底，而为了不至于长的太难看，你还得有一定的设计能力。这一下子把大部分人给难住了，咱们只是为了单纯的写写博客啊，至于有这么多要求吗？看到这里，很多人可能觉得此法不怎么方便啊，然则，正如刚刚反复强调的，&lt;code&gt;Jekyll&lt;/code&gt;已经有一个非常庞大的社区，这就意味着，你完全可以借鉴别人已经造好的轮子，放在&lt;code&gt;Jekyll&lt;/code&gt;这里，咱们应该成为主体（Theme）比较合适。本文推荐国内用户可以考虑一款&lt;a href=&#34;https://github.com/Huxpro/huxpro.github.io&#34;&gt;国人开发的主题&lt;/a&gt;。&lt;strong&gt;&lt;em&gt;本博客即是采用了这个主题&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Fork出自己的repo&lt;/p&gt;

&lt;p&gt;为了便于管理，建议先把&lt;a href=&#34;https://github.com/Huxpro/huxpro.github.io&#34;&gt;Huxpro&lt;/a&gt; fork到自己的账户下&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clone主题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:keysaim/huxpro.github.io.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以直接clone它的样板repo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:Huxpro/huxblog-boilerplate.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加自己的github.io repo&lt;/p&gt;

&lt;p&gt;clone了Huxpro的repo之后，还需要将自己的github.io repo添加到Huxpro repo中，以方便后面讲修改同步到自己的repo中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add mine https://github.com/tobiasalin/tobiasalin.github.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;mine&lt;/code&gt;是你自己repo的别名，当然，你完全可以用其它任何合法的名字。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改必要的配置&lt;/p&gt;

&lt;p&gt;clone之后的repo其实是Huxpro自己的博客网站，里面有非常多作者自己的博文，可根据自己的需要进行必要的删减。基于&lt;code&gt;Jekyll&lt;/code&gt;的博客网站，对于配置，非常重要的一个文件是&lt;code&gt;_config.yml&lt;/code&gt;文件，代开这个文件进行必要的修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Site settings
title: 窗外蟋蟀
SEOTitle: 窗外蟋蟀的博客 | Keysaim Blog
header-img: img/home-bg-hill.jpg
email: keysaim@gmail.com
description: &amp;quot;描述&amp;quot;
keyword: &amp;quot;窗外蟋蟀, keysaim&amp;quot;
url: &amp;quot;https://keysaim.github.io&amp;quot;
baseurl: &amp;quot;&amp;quot;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;编写发布博客&#34;&gt;编写发布博客&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Jekyll&lt;/code&gt;对于博文，都是要求放在&lt;code&gt;_posts&lt;/code&gt;目录下面，同时对博文的文件名有&lt;a href=&#34;https://jekyllrb.com/docs/posts/#creating-post-files&#34;&gt;严格的规定&lt;/a&gt;，必须保持格式&lt;code&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;，通常情况下，咱们采用推荐的&lt;code&gt;Markdown&lt;/code&gt;撰写博文，基于该格式，本博文的文件名为&lt;code&gt;2017-08-15-how-to-setup-your-github-io-blog.md&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;写好博文之后，就可以通过&lt;code&gt;git&lt;/code&gt;提交博文了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add _posts/2017-08-15-how-to-setup-your-github-io-blog.md
$ git commit -m &amp;quot;Add how to setup your github.io blog&amp;quot;
$ git push mine master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*请务必注意，这里提交的repo是&lt;code&gt;mine&lt;/code&gt;，也就是你自己的github.io repo。*等一会（通常几秒到几十秒不等），就可以打开自己的博客网站查看博文了，这里是我的博客网站&lt;code&gt;https://keysaim.github.io&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;本地查看自己的博客&#34;&gt;本地查看自己的博客&lt;/h2&gt;

&lt;p&gt;有时候，在提交到&lt;code&gt;github&lt;/code&gt;之前，咱们总想先看看博文的效果如何，既然&lt;code&gt;github&lt;/code&gt;采用的也是&lt;code&gt;Jekyll&lt;/code&gt;，那么咱们完全可以采用&lt;code&gt;Jekyll&lt;/code&gt;在本地构建网站，查看博文效果。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;按照&lt;code&gt;Ruby&lt;/code&gt;（请务必确保版本在&lt;code&gt;1.9.3&lt;/code&gt;以上）&lt;/p&gt;

&lt;p&gt;可以参照&lt;a href=&#34;https://www.ruby-lang.org/en/downloads/&#34;&gt;官网教程&lt;/a&gt;进行安装，这里，如果你使用的是Mac，可以安装如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install ruby
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装&lt;code&gt;Github pages&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Github pages&lt;/code&gt;其实就是&lt;code&gt;github&lt;/code&gt;基于&lt;code&gt;Jekyll&lt;/code&gt;用来构建&lt;code&gt;github.io&lt;/code&gt;的工具，安装好Ruby之后可以执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install github-pages
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开启&lt;code&gt;Jekyll&lt;/code&gt;本地服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd keysaim.github.io
$ jekyll serve --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，该服务会侦听在本地&lt;code&gt;4000&lt;/code&gt;的端口上，可以打开浏览器访问&lt;code&gt;http://127.0.0.1:4000&lt;/code&gt;，这样就可以在本地查看自己的博文效果了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;github.io&lt;/code&gt;通过基于&lt;code&gt;Jekyll&lt;/code&gt;工具的&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github pages&lt;/a&gt;来自动构建网站，同时本身又是&lt;code&gt;github&lt;/code&gt;的repo，为使用者提供完全的内容控制，十分便利灵活。当然，要用好这个工具，还是对你有一定的要求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;必须得有基本的&lt;code&gt;git&lt;/code&gt;使用基础&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;必须对前端有一定的概念&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;必须较为熟悉&lt;code&gt;Markdown&lt;/code&gt;撰写&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过，幸运的是，这三点不论哪一点，其实都是相对较为简单的，&lt;code&gt;git&lt;/code&gt;的基本使用，Google一下，我相信1小时学会不是太大问题；对前端的要求，由于前人已经造了足够多的轮子，咱们完全可以先借鉴别人的，等以后慢慢熟悉起来之后再考虑自己DIY；对于&lt;code&gt;Markdown&lt;/code&gt;，个人觉得其语法真的是非常的简单，只要静下心来，一个下午足够让你编写基本的文章了。&lt;/p&gt;

&lt;p&gt;最后，这里再次感谢&lt;a href=&#34;https://github.com/Huxpro/huxpro.github.io&#34;&gt;Huxpro&lt;/a&gt;提供本站的&lt;code&gt;Jekyll&lt;/code&gt;主题。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.smashingmagazine.com/2014/08/build-blog-jekyll-github-pages/&#34;&gt;Build A Blog With Jekyll And GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github pages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>用docker搭建全栈式应用（三）管理篇</title>
      <link>https://keysaim.github.io/post/docker/2016-06-23-full-stack-demo3/</link>
      <pubDate>Thu, 23 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/docker/2016-06-23-full-stack-demo3/</guid>
      
        <description>

&lt;h1 id=&#34;用docker搭建全栈式应用-三-管理篇&#34;&gt;用docker搭建全栈式应用 (三）—— 管理篇&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;https://keysaim.github.io/2016/05/30/full-stack-demo2/&#34;&gt;上一篇&lt;/a&gt;我们讲述了如何基于Dockerfile实现docker image的自动构建，并基于此重新实现了咱们本系列中的全栈式应用。然而，虽然构建过程实现了自动化，但是在实际部署的时候我们还是需要手动的理清所有服务的依赖关系，并依次启动所有服务，更严重的是，每次重启的时候，我们都需要重复这些操作，这个是不能接受的。&lt;/p&gt;

&lt;p&gt;那么有啥办法改善么？记得业内似乎总有这么个说法，大凡超过重复操作必须得用脚本实现自动化，此谓IT男的基本素养。既然如此，咱们也得用脚本自动化咱们的操作了。非常直接的一种方案就是咱自己写个shell的脚本，如下：
* 启动脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```shell
docker run -d --name redis-master redis-master
docker run -d --name redis-slave1 --link redis-master:master redis-slave1
docker run -d --name redis-slave2 --link redis-master:master redis-slave2
docker run -d --name app2 --link redis-master:redis app 0.0.0.0:8002
docker run -d --name haproxy --link app1:app1 --link app2:app2 -p 6301:6301 ha-app
```
看起来还可以吗，简单的几条语句。但是，咱可不要忘了一点，每个语句咱还木有检查执行的结果。还有这个只是启动的脚本，还有停止的脚本，清除的脚本等等。更要命的是，如果下次我部署其它类型的应用，尼玛还得把这一些列的脚本复制并修改一通，这个有点弱爆了的感觉啊。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来讲，IT界总是存在这一的规律，当一个烦恼只是你一个人的时候，OK你可以随便整了；当你觉得可能会是很多人的烦恼的时候，这时必须得已经有人提供了解决方案了。所以，在当下技术更新如此剧烈的年代，切记不要随便就自己吭哧吭哧的闷声瞎搞了，第一要务就是google之。一般情况下，总是与大神提供了解决方案，如果真心没有，那么恭喜你，赶紧自己整一个并开放出来，那么你就是那个大神了。&lt;/p&gt;

&lt;p&gt;同样，在咱们本文碰到的问题中，早就有对应的解决方案了，那就是基于Docker compose工具的服务管理。本文将详述如何基于Docker compose管理服务。当然，例子还是那个例子咯。&lt;/p&gt;

&lt;h2 id=&#34;docker-compose工具简介&#34;&gt;Docker Compose工具简介&lt;/h2&gt;

&lt;p&gt;关于Docker Compose，&lt;a href=&#34;https://docs.docker.com/compose/overview/&#34;&gt;官方&lt;/a&gt;其实有非常详尽的介绍。这里就简单的总结一下。&lt;/p&gt;

&lt;p&gt;那么，Docker Compose是什么呢？
* Docker的一个工具
* 定义，运行并管理多个容器应用
* 基于Compose文件
* 通常应用于开发、测试、CI环境&lt;/p&gt;

&lt;p&gt;Compose的使用一般与Dockerfile结合，包括三个步骤：
* 定义好所有应用的Dockerfile
* 在Compose文件中定义、配置好所有服务
* &lt;code&gt;docker-compose up&lt;/code&gt;启动你的服务&lt;/p&gt;

&lt;p&gt;下面，咱们就以本系列的经典例子：全栈式应用，来讲述Docker Compose的使用。&lt;/p&gt;

&lt;h2 id=&#34;基于docker-compose搭建-管理全栈式应用&#34;&gt;基于Docker Compose搭建、管理全栈式应用&lt;/h2&gt;

&lt;h3 id=&#34;docker-compose的安装&#34;&gt;Docker Compose的安装&lt;/h3&gt;

&lt;p&gt;安装过程其实非常简单，&lt;a href=&#34;https://docs.docker.com/compose/install/&#34;&gt;官方&lt;/a&gt;提供了非常详细的安装过程。这里讲述其中一种基于command line的安装方式。
* 使用curl下载Compose工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```
curl -L https://github.com/docker/compose/releases/download/1.7.1/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose
```
当然，这里使用的是1.7.1版本，如果有新版本发布了，你只需要修改成相应的版本即可。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加Compose工具执行权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试一下是否下载成功&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-compose --version
docker-compose version: 1.7.1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;compose文件的编写&#34;&gt;Compose文件的编写&lt;/h3&gt;

&lt;p&gt;前面我们讲了，一般来说，Compose的使用包括了三个步骤。由于在&lt;a href=&#34;https://keysaim.github.io/2016/05/30/full-stack-demo2/&#34;&gt;上一篇&lt;/a&gt;已经编写好了Dockerfile文件，这里咱们就直接开始Compose文件的编写这一步骤了。Docker默认使用的compose文件名字为&lt;code&gt;docker-compose.yml&lt;/code&gt;，这里还是老规矩，先列出本例子中使用的&lt;code&gt;docker-compose.yml&lt;/code&gt;文件，然后再详细解释。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: &amp;quot;2&amp;quot;
services:
    redis-master:
        build: master
        image: redis-master
        container_name: redis-master
        volumes:
            - /opt/demo/redis:/data

    redis-slave1:
        build: slave1
        image: redis-slave1
        container_name: redis-slave1
        links:
            - redis-master:master

    redis-slave2:
        build: slave2
        image: redis-slave2
        container_name: redis-slave2
        links:
            - redis-master:master

    app1:
        build: app
        image: app
        container_name: app1
        links:
            - redis-master:redis
        command: 0.0.0.0:8001

    app2:
        build: app
        image: app
        container_name: app2
        links:
            - redis-master:redis
        command: 0.0.0.0:8002

    haproxy:
        build: haproxy
        image: haapp
        container_name: haproxy
        links:
            - app1:app1
            - app2:app2
        ports:
            - 6301:6301
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细瞅一下这个文件，其实还是蛮一目了然的，不过这里现在咱们开始一点点进行解释吧。&lt;/p&gt;

&lt;p&gt;首先，必须注意到的是，docker compose文件其实采用的是常用的yaml文件格式进行定义，因此所有的定义必须符合yaml文件的规范。接下来分别解释每个yaml section。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;version&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;顾名思义，这个表示当前的&lt;code&gt;docker-compose.yml&lt;/code&gt;文件采用哪个版本的格式。这里采用了截止本文最新的版本2，至于跟版本1有啥不同，还请参考&lt;a href=&#34;https://docs.docker.com/compose/compose-file/#versioning&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;services&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;services&lt;/code&gt;部分定义了需要管理的所有的服务，docker compose将根据这部分的定义对它们进行管理，包括所有service对应的containers的启动、停止等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;redis-master&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这部分定义了&lt;code&gt;redis-master&lt;/code&gt;的container。在&lt;a href=&#34;https://keysaim.github.io/2016/05/30/full-stack-demo2/&#34;&gt;上一篇&lt;/a&gt;中，我们已经介绍了如何通过Dockerfile构建image，并手动启动了相应的container。这里，通过docker compose工具，我们可以将这两个过程都交给docker compose自动完成。这部分则对这两个过程进行了定义，包括如何构建以及如何启动。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;build&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这部分定义了该服务构建时的目录，docker compose会首先查找本地cache是否以及有了所需要的image，如果没有，则根据这里提供的目录，找到对应的Dockerfile，然后构建出相应的image。所以，这部分其实是可选的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;image&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这部分定义了该服务所需要的image的名字，如前述，docker compose会先查找本地cache有没有image定义的名字对应的image，如果有则直接启动，如果没有则会试图构建，构建出来的image名字为这部分定义的名字。这部分必须定义。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;container_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这部分定义了启动container之后，container的名字。这部分也是可选的，如果没有定义则会自动生成一个名字。如果定义了，必须保证名字在所有的services中都是唯一的。另外，如果定义了，也就意味着docker compose只能根据这个服务定义启动一个container了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;volumes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还记得在&lt;a href=&#34;https://keysaim.github.io/2016/05/30/full-stack-demo2/&#34;&gt;上一篇&lt;/a&gt;中介绍了在启动container时候如何挂载volumes，这里既是定义了该服务需要挂载的volumes，其格式跟之前讲述的一样。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，其它services的定义其实跟上面的基本差不多，另外多了其它几个定义。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;links&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这部分其实对应了咱们启动container时提供的&lt;code&gt;--link&lt;/code&gt;参数，可以在&lt;a href=&#34;https://keysaim.github.io/2016/05/16/full-stack-demo/&#34;&gt;第一篇&lt;/a&gt;中找到其详细解释。这里以列表的形式可以定义多个&lt;code&gt;--link&lt;/code&gt;，其格式也跟&lt;code&gt;--link&lt;/code&gt;的格式相同。需要注意的是，&lt;code&gt;links&lt;/code&gt;其实也定义了containers之间的依赖了，只有当&lt;code&gt;links&lt;/code&gt;中所需要的containers已经启动了，才可能建立这个link。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;command&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://keysaim.github.io/2016/05/30/full-stack-demo2/&#34;&gt;上一篇&lt;/a&gt;我们详细解释了Dockerfile中的&amp;rsquo;command&amp;rsquo;命令，这里的command定义将覆盖Dockerfile中定义的&lt;code&gt;command&lt;/code&gt;命令。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ports&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;从字面上可以很容易联想到这个对应于启动container时需要publish的端口。这部分同样以列表的形式提供了端口的定义。端口的具体格式跟启动container时候的一样，可以参考&lt;a href=&#34;https://keysaim.github.io/2016/05/30/full-stack-demo2/&#34;&gt;上一篇&lt;/a&gt;中的定义。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，我们已经清楚如何编写本例子对应的docker compose文件了，本系列中的例子所对应的docker compose文件其实也基本上表达了大多数情形下得使用。接下来，咱们看看如何利用docker compose工具根据这个compose文件管理所有服务了。&lt;/p&gt;

&lt;h3 id=&#34;用docker-compose管理服务&#34;&gt;用Docker compose管理服务&lt;/h3&gt;

&lt;p&gt;还记得&lt;a href=&#34;https://keysaim.github.io/2016/05/30/full-stack-demo2/&#34;&gt;上一篇&lt;/a&gt;中，咱们对containers的管理都是通过docker的各种命令进行的：run, stop, start, rm等等。同时，咱们还必须记住各种服务的依赖关系，每次根据依赖顺序启动各种服务。有了docker compose已经上面定义的compose文件，对服务的管理就变得非常的简单了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运行service&lt;/p&gt;

&lt;p&gt;手动运行的时候，我们采用的是&lt;code&gt;docker run&lt;/code&gt;命令，借助docker compose，假定我们要启动app1，运行的命令为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker-compose up app1
Creating network &amp;quot;dockerfullstackdemo_default&amp;quot; with the default driver
Creating redis-master
Creating app1
Attaching to app1

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了docker compose的&lt;code&gt;up&lt;/code&gt;命令，后面的参数是我们需要启动的service。这里是&lt;code&gt;app1&lt;/code&gt;，可以看到，docker compose工具会自动的计算出依赖关系，所以首先启动了&lt;code&gt;redis-master&lt;/code&gt;container，然后再启动了&lt;code&gt;app1&lt;/code&gt;container，最后attach到&lt;code&gt;app1&lt;/code&gt;container上面。一般情况下，我们都希望container运行在后台，这里可以加入&lt;code&gt;-d&lt;/code&gt;选项以后台的形式运行。&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;up&lt;/code&gt;命令后面不加任何的service，那么docker compose将启动compose文件中所有的服务。当然，它同样会自动计算好依赖关系，并按照顺序启动。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker-compose up -d
Creating network &amp;quot;dockerfullstackdemo_default&amp;quot; with the default driver
Creating redis-master
Creating redis-slave2
Creating redis-slave1
Creating app1
Creating app2
Creating haproxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看一下当前的状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                    NAMES
87eaa9cbf5a3        haapp               &amp;quot;haproxy -f haproxy.c&amp;quot;   About a minute ago   Up 57 seconds       0.0.0.0:6301-&amp;gt;6301/tcp   haproxy
7d6f46db93f0        app                 &amp;quot;python manage.py run&amp;quot;   About a minute ago   Up 59 seconds                                app2
899ca6403216        app                 &amp;quot;python manage.py run&amp;quot;   About a minute ago   Up About a minute                            app1
3d654392e255        redis-slave1        &amp;quot;docker-entrypoint.sh&amp;quot;   About a minute ago   Up About a minute   6379/tcp                 redis-slave1
56db43752731        redis-slave2        &amp;quot;docker-entrypoint.sh&amp;quot;   About a minute ago   Up About a minute   6379/tcp                 redis-slave2
dad9dd44a314        redis-master        &amp;quot;docker-entrypoint.sh&amp;quot;   About a minute ago   Up About a minute   6379/tcp                 redis-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，不加任何service的时候，&lt;code&gt;up&lt;/code&gt;命令启动了所有的服务。&lt;/p&gt;

&lt;p&gt;另外，&lt;code&gt;up&lt;/code&gt;命令还有个非常方便的特性，就是它会检查当前服务是否需要更新（所谓更新，其实指的是服务对应的image是否更新了），需要更新它会重启服务，同时还会检查是否某个服务不在运行，那么它也会把它启动起来。这里咱们做个简单的实验，先手动停掉一个服务，比如&lt;code&gt;app1&lt;/code&gt;，然后再次执行&lt;code&gt;up&lt;/code&gt;命令，看看结果如何。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先停掉&lt;code&gt;app1&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker stop app1
app1
# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
d6a21457ffae        haapp               &amp;quot;haproxy -f haproxy.c&amp;quot;   26 seconds ago      Up 23 seconds       0.0.0.0:6301-&amp;gt;6301/tcp   haproxy
69392ab206f3        app                 &amp;quot;python manage.py run&amp;quot;   29 seconds ago      Up 26 seconds                                app2
a98dc1605c92        redis-slave1        &amp;quot;docker-entrypoint.sh&amp;quot;   33 seconds ago      Up 31 seconds       6379/tcp                 redis-slave1
457b08940a6f        redis-slave2        &amp;quot;docker-entrypoint.sh&amp;quot;   36 seconds ago      Up 33 seconds       6379/tcp                 redis-slave2
b35ec7b3ef59        redis-master        &amp;quot;docker-entrypoint.sh&amp;quot;   39 seconds ago      Up 35 seconds       6379/tcp                 redis-master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再执行&lt;code&gt;up&lt;/code&gt;命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker-compose up -d
redis-master is up-to-date
redis-slave2 is up-to-date
redis-slave1 is up-to-date
Starting app1
app2 is up-to-date
haproxy is up-to-date
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检查一下&lt;code&gt;app1&lt;/code&gt;是否被重新启动了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
d6a21457ffae        haapp               &amp;quot;haproxy -f haproxy.c&amp;quot;   38 seconds ago      Up 35 seconds       0.0.0.0:6301-&amp;gt;6301/tcp   haproxy
69392ab206f3        app                 &amp;quot;python manage.py run&amp;quot;   41 seconds ago      Up 38 seconds                                app2
f9adfb75b10e        app                 &amp;quot;python manage.py run&amp;quot;   43 seconds ago      Up 4 seconds                                 app1
a98dc1605c92        redis-slave1        &amp;quot;docker-entrypoint.sh&amp;quot;   45 seconds ago      Up 43 seconds       6379/tcp                 redis-slave1
457b08940a6f        redis-slave2        &amp;quot;docker-entrypoint.sh&amp;quot;   48 seconds ago      Up 45 seconds       6379/tcp                 redis-slave2
b35ec7b3ef59        redis-master        &amp;quot;docker-entrypoint.sh&amp;quot;   51 seconds ago      Up 47 seconds       6379/tcp                 redis-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，确实&lt;code&gt;app1&lt;/code&gt;被重新启动了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;撤销服务&lt;/p&gt;

&lt;p&gt;与&lt;code&gt;up&lt;/code&gt;相反的是撤销服务，采用的是&lt;code&gt;down&lt;/code&gt;命令。但是与&lt;code&gt;up&lt;/code&gt;命令不同的是，&lt;code&gt;down&lt;/code&gt;不接受某个service作为参数，而是直接停止掉所有的服务。当然，它同样会自动计算好依赖关系，并按照启动的相反顺序撤销服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker-compose down
Stopping haproxy ... done
Stopping app2 ... done
Stopping app1 ... done
Stopping redis-slave1 ... done
Stopping redis-slave2 ... done
Stopping redis-master ... done
Removing haproxy ... done
Removing app2 ... done
Removing app1 ... done
Removing redis-slave1 ... done
Removing redis-slave2 ... done
Removing redis-master ... done
Removing network dockerfullstackdemo_default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看一下当前的状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有containers不仅被停掉了，而且被删掉了。可见&lt;code&gt;down&lt;/code&gt;命令首先会停掉所有的containers，然后会把所有停掉的containers全部删掉。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;停止服务&lt;/p&gt;

&lt;p&gt;停止服务跟撤销不同，它对应于&lt;code&gt;docker stop&lt;/code&gt;命令，而撤销则相当于先&lt;code&gt;stop&lt;/code&gt;，然后再&lt;code&gt;rm&lt;/code&gt;了。docker compose采用&lt;code&gt;stop&lt;/code&gt;命令来停止某个服务，与&lt;code&gt;down&lt;/code&gt;不同的是，它不会计算依赖关系，而是直接强行停止所指定的服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker-compose stop redis-master
Stopping redis-master ... done
# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
d6a21457ffae        haapp               &amp;quot;haproxy -f haproxy.c&amp;quot;   9 minutes ago       Up 9 minutes        0.0.0.0:6301-&amp;gt;6301/tcp   haproxy
69392ab206f3        app                 &amp;quot;python manage.py run&amp;quot;   10 minutes ago      Up 9 minutes                                 app2
f9adfb75b10e        app                 &amp;quot;python manage.py run&amp;quot;   10 minutes ago      Up 9 minutes                                 app1
a98dc1605c92        redis-slave1        &amp;quot;docker-entrypoint.sh&amp;quot;   10 minutes ago      Up 10 minutes       6379/tcp                 redis-slave1
457b08940a6f        redis-slave2        &amp;quot;docker-entrypoint.sh&amp;quot;   10 minutes ago      Up 10 minutes       6379/tcp                 redis-slave2
b35ec7b3ef59        redis-master        &amp;quot;docker-entrypoint.sh&amp;quot;   12 minutes ago      Exited (137) 2 minutes ago                            redis-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显，这里停掉&lt;code&gt;redis-master&lt;/code&gt;，它是&lt;code&gt;app1&lt;/code&gt;跟&lt;code&gt;app2&lt;/code&gt;的依赖，但是&lt;code&gt;stop&lt;/code&gt;命令并没有理会这些依赖，而是直接停掉了&lt;code&gt;redis-master&lt;/code&gt;服务，可以看到它的状态已经变为Exited状态了，基本上相当于直接手动调用&lt;code&gt;docker stop&lt;/code&gt;了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动服务&lt;/p&gt;

&lt;p&gt;与停止服务相对应，docker compose采用&lt;code&gt;start&lt;/code&gt;命令来启动某个停止的服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker-compose start redis-master
Starting redis-master
# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
d6a21457ffae        haapp               &amp;quot;haproxy -f haproxy.c&amp;quot;   15 minutes ago      Up 14 minutes       0.0.0.0:6301-&amp;gt;6301/tcp   haproxy
69392ab206f3        app                 &amp;quot;python manage.py run&amp;quot;   15 minutes ago      Up 15 minutes                                app2
f9adfb75b10e        app                 &amp;quot;python manage.py run&amp;quot;   15 minutes ago      Up 14 minutes                                app1
a98dc1605c92        redis-slave1        &amp;quot;docker-entrypoint.sh&amp;quot;   15 minutes ago      Up 15 minutes       6379/tcp                 redis-slave1
457b08940a6f        redis-slave2        &amp;quot;docker-entrypoint.sh&amp;quot;   15 minutes ago      Up 15 minutes       6379/tcp                 redis-slave2
b35ec7b3ef59        redis-master        &amp;quot;docker-entrypoint.sh&amp;quot;   15 minutes ago      Up 3 seconds        6379/tcp                 redis-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当试图启动某个被删掉的服务的时候，docker compose会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker-compose stop redis-master
Stopping redis-master ... done
# docker rm redis-master
redis-master
# docker-compose start redis-master
ERROR: No containers to start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，这种时候采用&lt;code&gt;up&lt;/code&gt;命令就可以了，不管服务是被停掉或者被删掉了，它都会正确的运行该服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker-compose start redis-master
ERROR: No containers to start
# docker-compose up -d redis-master
Creating redis-master
# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
a2ade91f045b        redis-master        &amp;quot;docker-entrypoint.sh&amp;quot;   29 seconds ago      Up 25 seconds       6379/tcp                 redis-master
d6a21457ffae        haapp               &amp;quot;haproxy -f haproxy.c&amp;quot;   19 minutes ago      Up 19 minutes       0.0.0.0:6301-&amp;gt;6301/tcp   haproxy
69392ab206f3        app                 &amp;quot;python manage.py run&amp;quot;   19 minutes ago      Up 19 minutes                                app2
f9adfb75b10e        app                 &amp;quot;python manage.py run&amp;quot;   19 minutes ago      Up 18 minutes                                app1
a98dc1605c92        redis-slave1        &amp;quot;docker-entrypoint.sh&amp;quot;   19 minutes ago      Up 19 minutes       6379/tcp                 redis-slave1
457b08940a6f        redis-slave2        &amp;quot;docker-entrypoint.sh&amp;quot;   19 minutes ago      Up 19 minutes       6379/tcp                 redis-slave2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，docker compose提供了非常多的命令，可以通过查看帮助看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker-compose --help
Define and run multi-container applications with Docker.

Usage:
  docker-compose [-f=&amp;lt;arg&amp;gt;...] [options] [COMMAND] [ARGS...]
  docker-compose -h|--help

Options:
  -f, --file FILE           Specify an alternate compose file (default: docker-compose.yml)
  -p, --project-name NAME   Specify an alternate project name (default: directory name)
  --verbose                 Show more output
  -v, --version             Print version and exit

Commands:
  build              Build or rebuild services
  config             Validate and view the compose file
  create             Create services
  down               Stop and remove containers, networks, images, and volumes
  events             Receive real time events from containers
  help               Get help on a command
  kill               Kill containers
  logs               View output from containers
  pause              Pause services
  port               Print the public port for a port binding
  ps                 List containers
  pull               Pulls service images
  restart            Restart services
  rm                 Remove stopped containers
  run                Run a one-off command
  scale              Set number of containers for a service
  start              Start services
  stop               Stop services
  unpause            Unpause services
  up                 Create and start containers
  version            Show the Docker-Compose version information
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，它提供了非常多的命令，基本上docker有的主要命令，它都有对应的命令。但是基本如此，在使用过程中，使用最多的是&lt;code&gt;up&lt;/code&gt;命令跟&lt;code&gt;down&lt;/code&gt;命令，前者可以非常方便的启动任何的服务，后者则会把所有服务撤销确保非常干净的使用环境。&lt;/p&gt;

&lt;p&gt;至此，咱们的docker compose就介绍到这里了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>用docker搭建全栈式应用 (二）构建篇</title>
      <link>https://keysaim.github.io/post/docker/2016-05-30-full-stack-demo2/</link>
      <pubDate>Mon, 30 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/docker/2016-05-30-full-stack-demo2/</guid>
      
        <description>

&lt;h1 id=&#34;用docker搭建全栈式应用-二-构建篇&#34;&gt;用docker搭建全栈式应用 (二）—— 构建篇&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;https://keysaim.github.io/2016/05/16/full-stack-demo/&#34;&gt;上一篇&lt;/a&gt;中, 我们已经较为详细的描述如何基于docker，搭建一套全栈式应用。web端采用Django，并使用HaProxy作为负载均衡。数据库采用redis，并使用master-slave的部署方式。前文基于从官方的docker registry的images，讲述了一步步如何启动配置各项服务。但是在实际部署中，不可能全部手动的完成这些事情，本文将讲述基于Dockerfile，来自动生成所需的Docker image，并将讲述基于构建的image如何启动服务。&lt;/p&gt;

&lt;p&gt;在前篇博文中，如何在docker中一步步部署服务。基本上主要包括了几个大的步骤：将配置拷贝到相应目录，同时做好修改；基于image启动docker container，同时挂载配置的目录；在container中启动服务。这样的部署方式有几个问题：
* 全部手动操作，每次多事重复劳动
* 需要手动进入container中启动服务，部署非常耗时
* 配置需要在外面修改，极大地违背了docker隔离性的设计理念&lt;/p&gt;

&lt;p&gt;那么，如何解决这些问题呢？这里将引入本文将要讲述的Docker的自动化构建机制。所谓自动化构建，其实主要指的是基于Dockerfile的构建方式。利用Dockerfile，我们可以非常方便的构建一个独立完整的应用，同时集成一系列部署时候的操作，使得自动化的部署得以实现。Dockerfile是一个文本文件，里面记录了一系列的命令和操作，给出了一个docker image组成的完整定义。关于Dockerfile的详细介绍，请务必参考&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;官方的文档&lt;/a&gt;，千万不要用X度，官方的文档其实讲述的非常清楚，而且基本上就一页就讲完了。&lt;/p&gt;

&lt;p&gt;ok, 下面咱们就开始讲述Docker的自动化构建部分。讲述之前，这里还是引入一下前文中的应用架构图，方便讲述及阅读。&lt;/p&gt;

&lt;div style=&#34;text-align:center&#34;&gt;
    &lt;img src=&#34;https://keysaim.github.io/img/blog-demoarch.png&#34; alt=&#34;&#34; width=&#34;400&#34;/&gt;
&lt;/div&gt;

&lt;h2 id=&#34;redis-master构建&#34;&gt;Redis-master构建&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;https://keysaim.github.io/2016/05/16/full-stack-demo/&#34;&gt;上一篇&lt;/a&gt;中，redis-master的构建主要包括如下步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取redis image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker pull redis
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动redis master container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -it --name redis-master -v `pwd`/master:/data redis /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置redis master&lt;/p&gt;

&lt;p&gt;主要是修改配置文件&lt;code&gt;master/redis.conf&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在container中启动redis service&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;全部手动的操作比较繁琐，使用Dockerfile将可以实现自动化构建。这里先将构建redis-master的Dockerfile先列出，然后在详细介绍。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM redis
COPY ./redis.conf /data/
CMD redis-server /data/redis.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此Dockerfile主要采用了三个命令。
* &lt;code&gt;FROM redis&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对应于手动操作中的`docker pull redis`，表示构建此image是基于官方docker registry中的redis image。Docker看到这个指令之后会首先从本地的cache中查找是否已经存在，如果存在就直接使用本地cache，如果不存在将自动的从docker registry下载。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;COPY ./redis.conf /data/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;COPY命令将指定的文件拷贝到docker image中。这里需要先配置好&lt;code&gt;redis.conf&lt;/code&gt;，这点与手动的不一样，手动的可以先配置好，也可以启动container之后再行配置，但是在Dockerfile中，由于将构建新的docker image，通常来讲里面得包含必须的文件。所以可以先配置好，然后直接打包到所要构建的image中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;CMD redis-server /data/redis.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CMD&lt;/code&gt;命令指定了基于此image启动的container运行时将启动什么服务命令。这里指定了将启动服务命令&lt;code&gt;redis-server /data/redis.conf&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来，咱们来基于这个Dockerfile来实际操作一下，看看具体的构建过程是如何进行的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为了节省时间，这里先假设依赖的image已经在本地cache中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
redis               latest              84dbf5edc313        2 weeks ago         184.8 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果本地没有也没关系，docker的构建工具会自动下载。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构建image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls
Dockerfile  redis.conf
# docker build -t redis-master .
Sending build context to Docker daemon 48.13 kB
Step 1 : FROM redis
 ---&amp;gt; 84dbf5edc313
Step 2 : COPY ./redis.conf /data/
 ---&amp;gt; 3cafd319458b
Removing intermediate container c7c2fb33b52b
Step 3 : CMD redis-server /data/redis.conf
 ---&amp;gt; Running in 30c859175110
 ---&amp;gt; 8c7a0742a542
Removing intermediate container 30c859175110
Successfully built 8c7a0742a542
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建的命令为&lt;code&gt;docker build -t redis-master .&lt;/code&gt;，其中&lt;code&gt;-t&lt;/code&gt;指定生成的image叫什么名字；&lt;code&gt;.&lt;/code&gt;指的是在当前目录下执行，docker将在当前目录查找名为&lt;code&gt;Dockerfile&lt;/code&gt;的文件，然后基于它进行构建。构建成功之后再看看本地的cache：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
redis-master        latest              8c7a0742a542        3 minutes ago       184.9 MB
redis               latest              84dbf5edc313        2 weeks ago         184.8 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，本地的cache中增加了一个名为&lt;code&gt;redis-master&lt;/code&gt;的image。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -d --name redis-master redis-master
1ab87eaefaccc47f91063d27db124d5573932439a46ff15204580b8cbbf3b91a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;-d&lt;/code&gt;是让container运行在后台，&lt;code&gt;--name&lt;/code&gt;则是指定container的名字。成功运行后，打印出来的就是container的ID。我们来看下当前运行的状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES
1ab87eaefacc        redis-master        &amp;quot;docker-entrypoint.sh&amp;quot;   2 minutes ago       Exited (0) 2 minutes ago                       redis-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到，非常奇怪的是container虽然成功的创建出来了，但是状态却是&lt;code&gt;Exited&lt;/code&gt;，似乎并没有成功的运行起来，其实准确来讲应该是自动退出了。一般情况下，如果一个container没有按照预想运行起来，咱们还是需要稍微的调试一番，这里最为常用的调试手段就是查看container运行的日志：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker logs redis-master

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现，并没有任何的日志输出。这是怎么回事呢？其实对于container为什么会自动退出，可能的原因会有非常多。但是，最为基本的一点必须需要清楚，那就是container的生命周期。container在创建并启动之后会自动运行Dockerfile中指定的&lt;code&gt;CMD&lt;/code&gt;，然后一直运行直到&lt;code&gt;CMD&lt;/code&gt;命令退出，container也会退出，*请注意*，&lt;strong&gt;&lt;em&gt;命令必须一直运行在前台&lt;/em&gt;&lt;/strong&gt;，否则container将视为命令自动退出，也就跟着退出了。重新查看我们这里启动的命令&lt;code&gt;redis-server /data/redis.conf&lt;/code&gt;，打开其中的配置文件可以发现其中一行配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;daemonize yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其意思就是指定redis-server以后台daemon的形式运行。这样我们就可以解释清楚了，当前的配置文件使得redis-server运行在后台，container肯定会自动退出了。&lt;/p&gt;

&lt;p&gt;那么问题来了，如何解决呢？很自然的我们会想到，修改配置让其运行在前台就好了，确实如此，修改如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;daemonize no
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在container外面修改了配置，很明显不会对已经存在的container有任何影响。当前的container是由当前的image生成的，因此，为了能够使得改动生效，咱们得重新构建image，并重新启动：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先，删除当前的container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker rm redis-master
redis-master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重新构建image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker build -t redis-master .
Sending build context to Docker daemon 48.13 kB
Step 1 : FROM redis
 ---&amp;gt; 84dbf5edc313
Step 2 : COPY ./redis.conf /data/
 ---&amp;gt; 82030daeddd8
Removing intermediate container 22b9f260a3af
Step 3 : CMD redis-server /data/redis.conf
 ---&amp;gt; Running in 8e90495733d8
 ---&amp;gt; 9893c50d215a
Removing intermediate container 8e90495733d8
Successfully built 9893c50d215a
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -d --name redis-master redis-master
803073f7771f2f20e887423b0bee6823c0247a54c971db38dec675743ba2747c
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检查状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
803073f7771f        redis-master        &amp;quot;docker-entrypoint.sh&amp;quot;   40 seconds ago      Up 37 seconds       6379/tcp            redis-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，container成功运行起来了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;修改配置，将service运行在前台确实是一种常用的解决办法，但是在有些情况下却并不适用，比如如果需要同时启动多个service，或者需要对service进行监控以确保在service crash的时候能够自动重启等。对于这些场景，可以考虑采用另一种解决方案：采用supervisord管理服务。关于如何使用supervisord，请参照&lt;a href=&#34;https://docs.docker.com/engine/admin/using_supervisord/&#34;&gt;官方的教程&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;简单测试&lt;/p&gt;

&lt;p&gt;container虽然成功运行起来了，但还是需要简单的测试一下是否服务运行正常，这里咱们需要在container中启动一下&lt;code&gt;bash&lt;/code&gt;调试一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开bash&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker exec -it redis-master bash
root@803073f7771f:/data#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;命令将在container中运行指定的命令，&lt;code&gt;-it&lt;/code&gt;其实是&lt;code&gt;-i -t&lt;/code&gt;的缩写，&lt;code&gt;-i&lt;/code&gt;意思是以交互的方式运行，&lt;code&gt;-t&lt;/code&gt;指的是要attach到指定的container，这里运行的命令是bash。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行redis cli&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@803073f7771f:/data# redis-cli
127.0.0.1:6379&amp;gt; set redis_app test
OK
127.0.0.1:6379&amp;gt; get redis_app
&amp;quot;test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，能够正常的设置并获取，说明运行正常。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，redis-master已经构建并运行成功。接下来我们将讲述其它服务是如何构建的。&lt;/p&gt;

&lt;h2 id=&#34;redis-slave1构建&#34;&gt;redis-slave1构建&lt;/h2&gt;

&lt;p&gt;在上一节中，我们已经对基于Dockerfile的构建方式有了较为详细的介绍，这里将主要讲述不一样的地方。
* 编写Dockerfile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```
FROM redis
COPY ./redis.conf /data/
CMD redis-server /data/redis.conf
```
这里基本上与redis-master一模一样。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;修改配置&lt;/p&gt;

&lt;p&gt;配置基本上跟&lt;a href=&#34;https://keysaim.github.io/2016/05/16/full-stack-demo/&#34;&gt;上一篇&lt;/a&gt;中一样，唯一需要修改的跟redis-master一样，redis-server必须运行在前台：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;daemonize no
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构建image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker build -t redis-slave1 .
Sending build context to Docker daemon 48.13 kB
Step 1 : FROM redis
 ---&amp;gt; 84dbf5edc313
Step 2 : COPY ./redis.conf /data/
 ---&amp;gt; 98ae8ed20a4d
Removing intermediate container 0c860e887400
Step 3 : CMD redis-server /data/redis.conf
 ---&amp;gt; Running in d0f9370ca3e9
 ---&amp;gt; 8804bb83f02e
Removing intermediate container d0f9370ca3e9
Successfully built 8804bb83f02e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成之后，本地cache如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
redis-slave1        latest              8804bb83f02e        About a minute ago   184.9 MB
redis-master        latest              9893c50d215a        43 minutes ago       184.9 MB
redis               latest              84dbf5edc313        2 weeks ago          184.8 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出增加了一个名为redis-slave1的image。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -d --name redis-slave1 --link redis-master:master redis-slave1
570c03cdb20cb34a688f9988b2283b42ee2b237986bb8713cc1ca2328b3e7a6b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里特别注意的是，与&lt;a href=&#34;https://keysaim.github.io/2016/05/16/full-stack-demo/&#34;&gt;上一篇&lt;/a&gt;中一样，必须将redis-master的container link起来。这里可以简单对比一下跟&lt;a href=&#34;https://keysaim.github.io/2016/05/16/full-stack-demo/&#34;&gt;上一篇&lt;/a&gt;中运行container命令的区别，在上一篇中运行的命令为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -it --name redis-slave1 --link redis-master:master -v `pwd`/slave1:/data redis /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，有了自动构建的image，就不再需要映射本地的配置目录了，也不需要直接运行一个交互式的bash了，container可以直接以&lt;code&gt;-d&lt;/code&gt;的形式运行在后台。&lt;/p&gt;

&lt;p&gt;检查一下container的状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker ps -a -f name=redis-slave1
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
570c03cdb20c        redis-slave1        &amp;quot;docker-entrypoint.sh&amp;quot;   4 minutes ago       Up 4 minutes        6379/tcp            redis-slave1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意到，这里检查状态的命令与之前不通，采用了&lt;code&gt;-f&lt;/code&gt;参数。&lt;code&gt;-f&lt;/code&gt;参数表示使用过滤器，这里的过滤器为&lt;code&gt;name=redis-slave1&lt;/code&gt;，意思为只显示名字中包括&lt;code&gt;redis-slave1&lt;/code&gt;的所有containers，这里就会直接显示刚刚创建的&lt;code&gt;redis-slave1&lt;/code&gt;的container。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;简单测试&lt;/p&gt;

&lt;p&gt;同样，需要对启动的服务进行简单的测试。redis-slave1由于是redis-master的一个slave，因此，我们刚刚在master中设置的&lt;code&gt;redis_app&lt;/code&gt;值，在redis-slave1中也应该可以看到，我们来测试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker exec -it redis-slave1 /bin/bash
root@570c03cdb20c:/data# redis-cli
127.0.0.1:6379&amp;gt; get redis_app
&amp;quot;test&amp;quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与之前一样，我们也启动一个交互式的bash用来测试，这里可以看到，在redis-slave1，我们并没有做任何值得设置，却直接获取到了redis-master中设置的&lt;code&gt;redis_app&lt;/code&gt;值。可见，redis-slave1工作正常。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;redis-slave2构建&#34;&gt;redis-slave2构建&lt;/h2&gt;

&lt;p&gt;redis-slave2的构建与redis-slave1除了名字不同之外基本上一模一样，这里讲不再赘述。&lt;/p&gt;

&lt;h2 id=&#34;app1的构建&#34;&gt;app1的构建&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;https://keysaim.github.io/2016/05/16/full-stack-demo/&#34;&gt;上一篇&lt;/a&gt;中, 我们已经创建了一个Django的APP，本文中我们继续使用它，你可以&lt;a href=&#34;https://github.com/keysaim/demos/tree/master/docker-redis-django/app/redisapp&#34;&gt;在这里&lt;/a&gt;找到APP的代码。假定代码放在&lt;code&gt;app/redisapp&lt;/code&gt;下面。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编写Dockerfile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM django
COPY ./redisapp /data/redisapp
WORKDIR /data/redisapp
ENV https_proxy=&amp;lt;replace with your proxy here&amp;gt;
RUN pip install redis
RUN python manage.py migrate
ENTRYPOINT [&amp;quot;python&amp;quot;, &amp;quot;manage.py&amp;quot;, &amp;quot;runserver&amp;quot;]
CMD [&amp;quot;0.0.0.0:8080&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个Dockerfile比之前的要稍微复杂点，这里引入了几个新的命令，我们将逐一解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;WORKDIR /data/redisapp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;WORKDIR&lt;/code&gt;指定了当前的工作目录，它将影响在这之后的命令的当前路径，如&lt;code&gt;RUN&lt;/code&gt;命令、&lt;code&gt;COPY&lt;/code&gt;命令，它们的当前路径都将为&lt;code&gt;WORKDIR&lt;/code&gt;所指定的路径。在这里，由于已经将APP的代码拷贝到了&lt;code&gt;/data/redisapp&lt;/code&gt;，因此，将工作目录设置到了&lt;code&gt;/data/redisapp&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ENV https_proxy=&amp;lt;replace with your proxy here&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于在后续的命令中需要在线下载，所以请务必根据你自身的网络及系统设置来决定是否需要设置网络代理，我这里的网络由于不能够直接访问https，所以设置了https的代理。&lt;code&gt;ENV&lt;/code&gt;用来设置环境变量，设置的环境变量将存在于构建过程已经后面运行的container中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;RUN pip install redis&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于APP依赖于redis，所以必须在运行之前安装好所有的依赖包。&lt;code&gt;RUN&lt;/code&gt;命令用于image的构建过程中执行某个命令，比如这里执行了&lt;code&gt;pip install redis&lt;/code&gt;，那么在构建过程中会执行该命令。一个Dockerfile中可以执行任意多个&lt;code&gt;RUN&lt;/code&gt;命令。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;RUN python manage.py migrate&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Django的APP在运行之前，必须保证数据库是准备好的。因此需要运行&lt;code&gt;python manage.py migrate&lt;/code&gt;准备好数据库。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ENTRYPOINT [&amp;quot;python&amp;quot;, &amp;quot;manage.py&amp;quot;, &amp;quot;runserver&amp;quot;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;咋一眼看过去，这个&lt;code&gt;ENTRYPOINT&lt;/code&gt;指令跟&lt;code&gt;CMD&lt;/code&gt;有些类似，都可以用来指定container运行时候应该执行什么命令，但实际上两者还是有较大的区别的，这里我们将详细讲述两者的不同。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ENTRYPOINT&lt;/code&gt;指令有两种格式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行格式：&lt;code&gt;ENTRYPOINT [&amp;quot;executable&amp;quot;, &amp;quot;param1&amp;quot;, &amp;quot;param2&amp;quot;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在执行格式中，可以指定运行的执行命令以及对应的参数，这种格式是推荐的格式。此格式中命令的定义必须是json array的格式，因此，必须使用双引号&lt;code&gt;&amp;quot;&lt;/code&gt;而不是单引号&lt;code&gt;&#39;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;特别需要注意的是&lt;/em&gt;&lt;/strong&gt;，使用该格式时，不需要指定所有的参数，而可以选择两种不同的方式提供剩余的参数：&lt;/p&gt;

&lt;p&gt;一种是在运行container时，所有在&lt;code&gt;docker run &amp;lt;image&amp;gt;&lt;/code&gt;后面的参数都将添加到&lt;code&gt;ENTRYPOINT&lt;/code&gt;的最后面，例如，在本例中，&lt;code&gt;ENTRYPOINT&lt;/code&gt;指定的命令为&lt;code&gt;python manage.py runserver&lt;/code&gt;，如果运行&lt;code&gt;docker run app 0.0.0.0:8001&lt;/code&gt;，那么在container中实际执行的命令将是&lt;code&gt;python manage.py runserver 0.0.0.0:8001&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;另一种就是通过&lt;code&gt;CMD&lt;/code&gt;指令提供剩余的默认参数，这点在接下来&lt;code&gt;CMD&lt;/code&gt;的介绍中会详述。其实现的功能也是类似，只不过在Dockerfile中直接进行定义，而前面一种则可以在运行时动态改变。&lt;/p&gt;

&lt;p&gt;很明显，如果两种都提供了，前一种将覆盖后一种定义的参数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;shell格式：&lt;code&gt;ENTRYPOINT command param1 param2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在shell格式中，也可以指定运行时执行的命令及对应的参数，不同的是指定的命令将由&lt;code&gt;shell&lt;/code&gt;启动。比如如果指定&lt;code&gt;ENTRYPOINT python manage.py runserver 0.0.0.0:8080&lt;/code&gt;，那么其实相当于采用执行格式的定义：&lt;code&gt;ENTRYPOINT [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;python&amp;quot;, &amp;quot;manage.py&amp;quot;, &amp;quot;runserver&amp;quot;, &amp;quot;0.0.0.0:8080&amp;quot;]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;必须注意的是&lt;/em&gt;&lt;/strong&gt;，在此格式下，运行的命令将不能够收到Unix signals，比如，在&lt;code&gt;docker stop&lt;/code&gt;时将不会收到&lt;code&gt;SIGTERM&lt;/code&gt;信号。另外，与执行格式不同的是，此格式也无法接受其它参数，必须在指令中定义所有的参数。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;CMD&lt;/code&gt;命令有三种格式，分别代表了三种不同的用法：
* 执行格式：&lt;code&gt;CMD [&amp;quot;executable&amp;quot;,&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;与`ENTRYPOINT`类似，在执行格式中，可以指定运行的执行命令以及对应的参数，这种格式是推荐的格式。改格式中命令的定义必须是json array的格式，因此，必须使用双引号`&amp;quot;`而不是单引号`&#39;`。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认参数格式：&lt;code&gt;CMD [&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;默认参数格式主要用来服务于&lt;code&gt;ENTRYPOINT&lt;/code&gt;指令，我们知道，在&lt;code&gt;ENTRYPOINT&lt;/code&gt;指令中，我们可以指定container运行时执行的命令以及相应的参数，但是有时候有些参数我们并不想直接在&lt;code&gt;ENTRYPOINT&lt;/code&gt;中全部指定，这样的话我们可以使用&lt;code&gt;CMD&lt;/code&gt;来存放其余的参数。&lt;code&gt;CMD&lt;/code&gt;定义的参数将会直接加在&lt;code&gt;ENTRYPOINT&lt;/code&gt;指令的后面。在外面的例子中，可以看到采用了默认参数格式，因此运行时默认的命令将是：&lt;code&gt;python manage.py runserver 0.0.0.0:8080&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;shell格式：&lt;code&gt;CMD command param1 param2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个与&lt;code&gt;ENTRYPOINT&lt;/code&gt;的shell格式基于类似。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果同时定义多个&lt;code&gt;CMD&lt;/code&gt;指令时，只有最后一个有效。虽然&lt;code&gt;ENTRYPOINT&lt;/code&gt;与&lt;code&gt;CMD&lt;/code&gt;都可以直接定义执行的命令，但是如果同时两者存在，则只有&lt;code&gt;ENTRYPOINT&lt;/code&gt;有效，而&lt;code&gt;CMD&lt;/code&gt;则会以默认参数的形式添加到&lt;code&gt;ENTRYPOINT&lt;/code&gt;之后，所以请务必注意这种情形。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;CMD [&amp;quot;0.0.0.0:8080&amp;quot;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这就是&lt;code&gt;CMD&lt;/code&gt;的默认参数格式，这里指定APP默认运行时绑定的地址跟端口。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构建image&lt;/p&gt;

&lt;p&gt;编写完Dockerfile之后，构建image如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker build -t app .
Sending build context to Docker daemon  21.5 kB
Step 1 : FROM django
 ---&amp;gt; 3b0bc67346a2
Step 2 : COPY ./redisapp /data/redisapp
 ---&amp;gt; 1a668d3c3bd9
Removing intermediate container 3f3688a5c473
Step 3 : WORKDIR /data/redisapp
 ---&amp;gt; Running in 8e8e88e9ff4d
 ---&amp;gt; 7a4a59e854e1
Removing intermediate container 8e8e88e9ff4d
Step 4 : ENV https_proxy http://proxy-rtp-1.cisco.com:80/
 ---&amp;gt; Running in b9a103263162
 ---&amp;gt; 77e7049eb696
Removing intermediate container b9a103263162
Step 5 : RUN pip install redis
 ---&amp;gt; Running in 0c63bf7804e9
Collecting redis
  Downloading redis-2.10.5-py2.py3-none-any.whl (60kB)
Installing collected packages: redis
Successfully installed redis-2.10.5
You are using pip version 7.1.2, however version 8.1.2 is available.
You should consider upgrading via the &#39;pip install --upgrade pip&#39; command.
 ---&amp;gt; 5d20c0583060
Removing intermediate container 0c63bf7804e9
Step 6 : RUN python manage.py migrate
 ---&amp;gt; Running in a2310253ce5a
Operations to perform:
  Apply all migrations: auth, contenttypes, sessions, admin
Running migrations:
  Rendering model states... DONE
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying sessions.0001_initial... OK
 ---&amp;gt; 0019f76fcffc
Removing intermediate container a2310253ce5a
Step 7 : ENTRYPOINT python manage.py runserver
 ---&amp;gt; Running in d2ec8f7210d5
 ---&amp;gt; c40b9e6262df
Removing intermediate container d2ec8f7210d5
Step 8 : CMD 0.0.0.0:8080
 ---&amp;gt; Running in 262f54b7a3e4
 ---&amp;gt; e79f435e0ebe
Removing intermediate container 262f54b7a3e4
Successfully built e79f435e0ebe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看下当前的cache：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
app                 latest              e79f435e0ebe        58 minutes ago      434.2 MB
redis-slave1        latest              8804bb83f02e        29 hours ago        184.9 MB
redis-slave2        latest              8804bb83f02e        29 hours ago        184.9 MB
redis-master        latest              9893c50d215a        29 hours ago        184.9 MB
redis               latest              84dbf5edc313        2 weeks ago         184.8 MB
django              latest              3b0bc67346a2        3 weeks ago         433.5 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -d --name app1 --link redis-master:redis app 0.0.0.0:8001
725e15a560bab804ec10a80d110fc872f0faa88155c5da6e5534574d45e1e657
# docker ps -f name=app1
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
725e15a560ba        app                 &amp;quot;python manage.py run&amp;quot;   12 seconds ago      Up 9 seconds                            app1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里启动container &lt;code&gt;app1&lt;/code&gt;时，传入参数&lt;code&gt;0.0.0.0:8001&lt;/code&gt;使得其运行在8001端口上面。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;app2的构建&#34;&gt;app2的构建&lt;/h2&gt;

&lt;p&gt;app2的构建与app1一致，并且共用image &lt;code&gt;app&lt;/code&gt;，只是在启动container的时候改用端口8002，因此这里不再赘述。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -d --name app2 --link redis-master:redis app 0.0.0.0:8002
d201177cdb941d2b399142c2fd13960c44eb88b98164d904b626c31f09277c40
# docker ps -f name=app2
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
d201177cdb94        app                 &amp;quot;python manage.py run&amp;quot;   20 seconds ago      Up 17 seconds                           app2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;haproxy的构建&#34;&gt;HaProxy的构建&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编写Dockerfile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM haproxy
COPY ./haproxy.cfg /data/
WORKDIR /data/
ENTRYPOINT [&amp;quot;haproxy&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;haproxy.cfg&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要就是把依赖的配置文件拷贝到合适的位置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构建image&lt;/p&gt;

&lt;p&gt;我们还记得在&lt;a href=&#34;https://keysaim.github.io/2016/05/16/full-stack-demo/&#34;&gt;上一篇&lt;/a&gt;中，haproxy实际上是以daemon运行在后台的，为了防止container自动退出，必须得对&lt;code&gt;haproxy.cfg&lt;/code&gt;进行修改，找到这样的行&lt;code&gt;daemon&lt;/code&gt;删掉就好了。然后开始构建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker build -t ha-app .
Sending build context to Docker daemon 4.096 kB
Step 1 : FROM haproxy
 ---&amp;gt; 46bc5babcc18
Step 2 : COPY ./haproxy.cfg /data/
 ---&amp;gt; 46af090db6f4
Removing intermediate container 653e599fab22
Step 3 : WORKDIR /data/
 ---&amp;gt; Running in 422b09b8ecac
 ---&amp;gt; 1e09826430a7
Removing intermediate container 422b09b8ecac
Step 4 : ENTRYPOINT haproxy -f haproxy.cfg
 ---&amp;gt; Running in 1d088bd54b55
 ---&amp;gt; ed5c3db7822b
Removing intermediate container 1d088bd54b55
Successfully built ed5c3db7822b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看下本地的cache：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ha-app              latest              ed5c3db7822b        7 minutes ago       139.1 MB
app                 latest              e79f435e0ebe        About an hour ago   434.2 MB
redis-slave1        latest              8804bb83f02e        29 hours ago        184.9 MB
redis-slave2        latest              8804bb83f02e        29 hours ago        184.9 MB
redis-master        latest              9893c50d215a        30 hours ago        184.9 MB
haproxy             latest              46bc5babcc18        2 weeks ago         139.1 MB
redis               latest              84dbf5edc313        2 weeks ago         184.8 MB
django              latest              3b0bc67346a2        3 weeks ago         433.5 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出增加了一个名为&lt;code&gt;ha-app&lt;/code&gt;的image。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -d --name haproxy --link app1:app1 --link app2:app2 -p 6301:6301 ha-app
3cdf747daa07e254da67a1b930e5ef728061bd0dabd598703ed47e9d6e59f104
# docker ps -f name=haproxy
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
3cdf747daa07        ha-app              &amp;quot;haproxy -f haproxy.c&amp;quot;   10 seconds ago      Up 7 seconds        0.0.0.0:6301-&amp;gt;6301/tcp   haproxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，为了能够访问服务，我们将haproxy的端口映射为本地的6301端口，这样我们可以通过这个端口访问我们的APP服务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试服务&lt;/p&gt;

&lt;p&gt;打开浏览器，访问url: &lt;code&gt;http://&amp;lt;host ip&amp;gt;:6301/query/&lt;/code&gt;，可以得到结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hello world from 725e15a560ba, with value: b&#39;test&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，成功的从container&lt;code&gt;725e15a560ba&lt;/code&gt;中成功查询了redis数据库并返回了应答。再次刷新一下可以得到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hello world from d201177cdb94, with value: b&#39;test&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，应答从上一个container变成了另外一台，可见haproxy正常工作了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，我们已经完成了采用Dockerfile来自动化构建我们之前的全栈式服务了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>用docker搭建全栈式应用（一）基础篇</title>
      <link>https://keysaim.github.io/post/docker/2016-05-16-full-stack-demo/</link>
      <pubDate>Mon, 16 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/docker/2016-05-16-full-stack-demo/</guid>
      
        <description>

&lt;h1 id=&#34;用docker搭建全栈式应用&#34;&gt;用docker搭建全栈式应用&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;本文将以docker为基础，搭建一套简单的应用案例。该案例的应用架构将采用redis的master-slave模式作为数据存储，以django为框架提供web访问，以haproxy作为负载均衡。其架构图如下.&lt;/p&gt;

&lt;div style=&#34;text-align:center&#34;&gt;
    &lt;img src=&#34;https://keysaim.github.io/img/blog-demoarch.png&#34; alt=&#34;&#34; width=&#34;400&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;其中App1和App2属于同一个Django的APP.&lt;/p&gt;

&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;

&lt;h3 id=&#34;获取相应的docker-images&#34;&gt;获取相应的docker images&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以直接从docker官方获取images&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker pull django
$ docker pull redis
$ docker pull haproxy
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取成功之后，检查一下images是否真的ok&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
haproxy             latest              46bc5babcc18        3 days ago          139.1 MB
redis               latest              84dbf5edc313        4 days ago          184.8 MB
django              latest              3b0bc67346a2        9 days ago          433.5 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检查一下各自的版本(root权限)
redis版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -it redis /bin/bash
root@a3ca293915cb:/data# redis-server -v
Redis server v=3.2.0 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5382f69a4e75566b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;haproxy版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -it haproxy /bin/bash
root@b11f07766c49:/# haproxy -v
HA-Proxy version 1.6.5 2016/05/10
Copyright 2000-2016 Willy Tarreau &amp;lt;willy@haproxy.org&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;django版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -it django /bin/bash
root@1daf8d846018:/# django-admin version
1.9.6
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检查完后，可以用&lt;code&gt;docker rm&lt;/code&gt;把不用的containers删掉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES
1daf8d846018        django              &amp;quot;/bin/bash&amp;quot;              2 minutes ago       Exited (0) 6 seconds ago                       sleepy_hypatia
b11f07766c49        haproxy             &amp;quot;/docker-entrypoint.s&amp;quot;   3 minutes ago       Exited (0) 2 minutes ago                       elegant_tesla
a3ca293915cb        redis               &amp;quot;docker-entrypoint.sh&amp;quot;   5 minutes ago       Exited (0) 3 minutes ago                       stupefied_cray
# docker rm `docker ps -a | grep &#39;Exited&#39; | awk &#39;{print $1}&#39;`
1daf8d846018
b11f07766c49
a3ca293915cb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上，本文各版本采用如下:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;service&lt;/th&gt;
&lt;th&gt;version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;haproxy&lt;/td&gt;
&lt;td&gt;1.6.5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;django&lt;/td&gt;
&lt;td&gt;1.9.6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;redis&lt;/td&gt;
&lt;td&gt;3.2.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;启动containers&#34;&gt;启动containers&lt;/h2&gt;

&lt;p&gt;本案例中containers的有关启动配置如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;container&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;image&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;service&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;ports&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;volumes&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;links&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;redis-master&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis-server&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;master:/data&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;redis-slave1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis-server&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;slave1:/data&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis-master:master&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;redis-slave2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis-server&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;slave2:/data&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis-master:master&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;app1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;django&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;django app&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;app:/data&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis-master:redis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;app2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;django&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;django app&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;app:/data&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;redis-master:redis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;haproxy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;haproxy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;haproxy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6301:6301&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;haproxy:/data&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;app1:app1 app2:app2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;启动redis&#34;&gt;启动redis&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动redis-master
在本地当前目录下创建子目录&lt;code&gt;master&lt;/code&gt;，并将&lt;code&gt;master&lt;/code&gt;挂载到container里的&lt;code&gt;/data&lt;/code&gt;目录。container名字为&lt;code&gt;redis-master&lt;/code&gt;。为了方便调试，这里同时启动交互式模式&lt;code&gt;-it&lt;/code&gt;，并同时打开&lt;code&gt;bash&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mkdir master
# docker run -it --name redis-master -v `pwd`/master:/data redis /bin/bash
root@3d187b223f56:/data#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加一个测试条目，取key为&lt;code&gt;redis_app&lt;/code&gt;，该测试条目将被app1跟app2查询:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@3d187b223f56:/data# redis-cli
127.0.0.1:6379&amp;gt; set redis_app &amp;quot;Hello redis app!&amp;quot;
OK
127.0.0.1:6379&amp;gt; get redis_app
&amp;quot;Hello redis app!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动redis-slave1
本文案例中将采用两个redis的slave，这里首先启动第一个。container名字为&lt;code&gt;redis-slave1&lt;/code&gt;，同时为了方便的连接到redis master，这里直接用&lt;code&gt;--link&lt;/code&gt;将&lt;code&gt;redis-master&lt;/code&gt;container连接同时命名为&lt;code&gt;master&lt;/code&gt;。其实际效果相当于往&lt;code&gt;/etc/hosts&lt;/code&gt;添加一条记录，映射&lt;code&gt;master&lt;/code&gt;的域名到&lt;code&gt;redis-master&lt;/code&gt;的IP。通过这种方式，就不需要手工的添加master的IP，docker在启动的时候会自动添加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -it --name redis-slave1 --link redis-master:master -v `pwd`/slave1:/data redis /bin/bash
root@cef73ae816be:/data# cat /etc/hosts
172.17.0.3      cef73ae816be
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.2      master 3d187b223f56 redis-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，&lt;code&gt;--link&lt;/code&gt;实际上在&lt;code&gt;/etc/hosts&lt;/code&gt;下添加了一条新的映射，分别把&lt;code&gt;redis-master&lt;/code&gt;的别名&lt;code&gt;master&lt;/code&gt;、container ID以及container name映射到master的IP。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;172.17.0.2      master 3d187b223f56 redis-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有错误，那么上面在master中设置的条目应该可以查询到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@cef73ae816be:/data# redis-cli
127.0.0.1:6379&amp;gt; get redis_app
&amp;quot;Hello redis app!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动redis-slave2
与redis-slave1同样的方式启动redis-slave2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -it --name redis-slave2 --link redis-master:master -v `pwd`/slave2:/data redis /bin/bash
root@1f22e9e15e8b:/data# cat /etc/hosts
172.17.0.4      1f22e9e15e8b
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.2      master 3d187b223f56 redis-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有错误，那么上面在master中设置的条目应该可以查询到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@cef73ae816be:/data# redis-cli
127.0.0.1:6379&amp;gt; get redis_app
&amp;quot;Hello redis app!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动app1
app1需要连接到redis服务，因此需要把&lt;code&gt;redis-master&lt;/code&gt;container连起来。同时为其创建&lt;code&gt;app&lt;/code&gt;目录，由于app1跟app2共享同一个Django项目，这里就不再单独为他们创建各自的目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mkdir app
# docker run -it --name app1 --link redis-master:redis -v `pwd`/app/:/data django /bin/bash
root@7e6e49321993:/# 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;h3 id=&#34;配置redis&#34;&gt;配置redis&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取redis初始配置&lt;/p&gt;

&lt;p&gt;本文采用的版本为3.2.0, 可通过如下方式获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# wget https://raw.githubusercontent.com/antirez/redis/3.2.0/redis.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置redis-master&lt;/p&gt;

&lt;p&gt;拷贝&lt;code&gt;redis.conf&lt;/code&gt;到&lt;code&gt;master&lt;/code&gt;目录.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cp redis.conf master/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑改配置文件。默认里面有非常多的配置选项，这里只需要关注几个，并改成如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind 0.0.0.0
protected-mode yes
daemonize yes
logfile /var/log/redis.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于已经将&lt;code&gt;./master&lt;/code&gt;挂载到container的&lt;code&gt;/data&lt;/code&gt;目录，因此本地的改动在container里面也是可见的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置redis-slave1&lt;/p&gt;

&lt;p&gt;拷贝&lt;code&gt;redis.conf&lt;/code&gt;到&lt;code&gt;slave1&lt;/code&gt;目录.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cp redis.conf slave1/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑改配置文件。默认里面有非常多的配置选项，这里只需要关注几个，并改成如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind 0.0.0.0
protected-mode yes
daemonize yes
logfile /var/log/redis.log
slaveof master 6379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一项&lt;code&gt;slaveof&lt;/code&gt;将slave1设置为master的slave。同样，由于已经将&lt;code&gt;./slave1&lt;/code&gt;挂载到container的&lt;code&gt;/data&lt;/code&gt;目录，因此本地的改动在container里面也是可见的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置redis-slave2&lt;/p&gt;

&lt;p&gt;配置方式与&lt;code&gt;redis-slave1&lt;/code&gt;一致，因此，直接拷贝&lt;code&gt;slave1/redis.conf&lt;/code&gt;到&lt;code&gt;slave2&lt;/code&gt;目录.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cp slave1/redis.conf slave2/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置django-app&#34;&gt;配置Django App&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;配置app1&lt;/p&gt;

&lt;p&gt;首先需要创建Django项目,这需要登录到&lt;code&gt;app1&lt;/code&gt;系统中才能够调用Django命令来创建。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker attach app1
root@7e6e49321993:/# cd /data
root@7e6e49321993:/# django-admin startproject redisapp
root@4b8240acb25a:/data# ls
redisapp
root@4b8240acb25a:/data# cd redisapp/
root@4b8240acb25a:/data/redisapp# ls
manage.py  redisapp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来需要编辑Django代码以支持本案例中一个简单的API：&lt;code&gt;/query/&lt;/code&gt;，此API将获取redis中的key为&lt;code&gt;redis_app&lt;/code&gt;的值（请注意，该值在上面启动redis的时候已经设置好了），并将结果返回给浏览器。由于container中大量的linux工具都没有，因此需要到主机上去编辑。&lt;code&gt;app1&lt;/code&gt;container将&lt;code&gt;app&lt;/code&gt;目录挂载进去了，因此在container中的创建的Django项目实际上在&lt;code&gt;app&lt;/code&gt;目录下也是可见的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安卓redis client&lt;/p&gt;

&lt;p&gt;由于django app需要访问redis数据库，因此需要先安装redis client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@7e6e49321993:/data/redisapp# pip install redis
Collecting redis
  Downloading redis-2.10.5-py2.py3-none-any.whl (60kB)
      100% |████████████████████████████████| 61kB 123kB/s
      Installing collected packages: redis
      Successfully installed redis-2.10.5
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑&lt;code&gt;views.py&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# vim app/redisapp/redisapp/views.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始状态，&lt;code&gt;views.py&lt;/code&gt;文件并不存在，添加并编辑，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from django.http import HttpResponse
import socket
import redis


def query(request):
    r = redis.StrictRedis(host=&#39;redis&#39;, port=6379, db=0)
    value = r.get(&#39;redis_app&#39;)
    return HttpResponse(&#39;hello world from &#39; + socket.gethostname() + &#39;, with value: &#39; + str(value))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑&lt;code&gt;urls.py&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# vim app/redisapp/redisapp/views.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑内容如下，只要是添加&lt;code&gt;views.py&lt;/code&gt;中定义的view函数跟url的对应：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from django.conf.urls import url
from django.contrib import admin

from redisapp.views import *

urlpatterns = [
    url(r&#39;^admin/&#39;, admin.site.urls),
        url(r&#39;^query/&#39;, query),
        ]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑&lt;code&gt;settings.py&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# vim app/redisapp/redisapp/settings.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是讲默认生成的&lt;code&gt;redisapp&lt;/code&gt;添加到&lt;code&gt;INSTALLED_APPS&lt;/code&gt;中，添加完后应该如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;INSTALLED_APPS = [
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;redisapp&#39;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初始化数据库&lt;/p&gt;

&lt;p&gt;在启动django程序之前，必须初始化数据库。默认情况下，采用的sqlite数据库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@2298dd360bbd:/data/redisapp# python manage.py migrate
Operations to perform:
  Apply all migrations: admin, contenttypes, sessions, auth
Running migrations:
  Rendering model states... DONE
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying sessions.0001_initial... OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，app1已经全部配置并初始化完毕。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置app2&lt;/p&gt;

&lt;p&gt;app2与app1共享同一个Django项目，因此不需要为app2做任何特别的配置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置haproxy&lt;/p&gt;

&lt;p&gt;haproxy依赖于它的配置文件，在配置文件中必须把app1跟app2都加进去，这样haproxy就可以为他们做load balance了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# vim haproxy/haproxy.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
  maxconn 50000
  daemon
  pidfile /var/run/haproxy.pid
  log   127.0.0.1       local0
  nbproc 4
  #debug

defaults
  mode http
  balance roundrobin
  maxconn 25000
  option httplog
  option abortonclose
  option httpclose
  option forwardfor
  option redispatch
  option redispatch

  retries 3

  timeout client  30s
  timeout connect 30s
  timeout server  30s


listen redis_proxy
  bind :6301
  mode http
  stats enable
  stats uri /stats
  log   127.0.0.1       local0 debug
  server app1 app1:8001 check inter 2000 rise 2 fall 5
  server app2 app2:8002 check inter 2000 rise 2 fall 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要调试，可以吧&lt;code&gt;global&lt;/code&gt;中的&lt;code&gt;debug&lt;/code&gt;打开。特别注意的是关于app1跟app2的配置，必须跟他们启动的端口保持一致。因为在前面已经通过&lt;code&gt;--link&lt;/code&gt;将&lt;code&gt;app&lt;/code&gt;以及&lt;code&gt;app2&lt;/code&gt;连接进来，因此在写&lt;code&gt;address:port&lt;/code&gt;时候可以直接使用app1跟app2。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;启动services&#34;&gt;启动services&lt;/h2&gt;

&lt;h3 id=&#34;启动redis-service&#34;&gt;启动redis service&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动redis-master service&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;attach &lt;code&gt;redis-master&lt;/code&gt; container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker start redis-master
redis-master
# docker attach redis-master
root@3d187b223f56:/data#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@3d187b223f56:/data# redis-server redis.conf
root@3d187b223f56:/data# redis-cli
127.0.0.1:6379&amp;gt; get redis_app
&amp;quot;Hello redis app!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动redis-slave1 service&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;attach &lt;code&gt;redis-slave1&lt;/code&gt; container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker start redis-slave1
redis-slave1
root@neil-centos1:hademo# docker attach redis-slave1
root@cef73ae816be:/data# redis-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@cef73ae816be:/data# redis-server redis.conf
root@cef73ae816be:/data# redis-cli
127.0.0.1:6379&amp;gt; get redis_app
&amp;quot;Hello redis app!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动redis-slave2 service&lt;/p&gt;

&lt;p&gt;与启动redis-slave1 service一样，这里不再赘述。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;启动app-service&#34;&gt;启动app service&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动app1 service&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;attach &lt;code&gt;app1&lt;/code&gt; container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker start app1
app1
root@neil-centos1:hademo# docker attach app1
root@7e6e49321993:/# 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@7e6e49321993:/data# cd redisapp/
root@7e6e49321993:/data# python manage.py runserver 0.0.0.0:8001
Performing system checks...

System check identified no issues (0 silenced).
May 16, 2016 - 12:51:39
Django version 1.9.6, using settings &#39;redisapp.settings&#39;
Starting development server at http://0.0.0.0:8001/
Quit the server with CONTROL-C.

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动app2 service&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;attach &lt;code&gt;app2&lt;/code&gt; container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; docker start app2
 app2
 # docker attach app2
 root@13d9f084c18b:/#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@13d9f084c18b:/data# cd redisapp/
root@13d9f084c18b:/data/redisapp# python manage.py runserver 0.0.0.0:8002
Performing system checks...

System check identified no issues (0 silenced).
May 16, 2016 - 12:56:08
Django version 1.9.6, using settings &#39;redisapp.settings&#39;
Starting development server at http://0.0.0.0:8002/
Quit the server with CONTROL-C.

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;启动haproxy-service&#34;&gt;启动haproxy service&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;attach &lt;code&gt;haproxy&lt;/code&gt; container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker start haproxy
haproxy
# docker attach haproxy
root@7e0f805cd85c:/#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@7e0f805cd85c:/data# haproxy -f haproxy.cfg
[WARNING] 136/130034 (6) : Proxy &#39;redis_proxy&#39;: in multi-process mode, stats will be limited to process assigned to the current request.
root@7e0f805cd85c:/data#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，所有的service已经成功启动。可以通过uri &lt;code&gt;http://&amp;lt;host ip&amp;gt;:6031/query/&lt;/code&gt;访问本案例中web service。还可以通过&lt;code&gt;http://&amp;lt;host ip&amp;gt;:6031/stats&lt;/code&gt;来查询haproxy的统计信息。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;本文中所涉及的配置以及代码可以在这个github repo找到: &lt;a href=&#34;https://github.com/keysaim/demos/tree/master/docker-redis-django&#34;&gt;https://github.com/keysaim/demos/tree/master/docker-redis-django&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>The golang programming language</title>
      <link>https://keysaim.github.io/post/note/2016-04-23-the-golang-book/</link>
      <pubDate>Sat, 23 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/note/2016-04-23-the-golang-book/</guid>
      
        <description>

&lt;h1 id=&#34;notes&#34;&gt;Notes&lt;/h1&gt;

&lt;h2 id=&#34;section-2-program-structure&#34;&gt;Section 2, Program Structure&lt;/h2&gt;

&lt;h3 id=&#34;nested-block-in-if-else-if-else-block&#34;&gt;nested block in if-else if-else block&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	if x, y := 100, 200; x &amp;gt; 1000 {
	} else if x := &amp;quot;hello&amp;quot;; y &amp;gt; 0 { //this x shadow the &#39;x&#39; in if
		fmt.Println(x, y)
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scope-shaw-issue&#34;&gt;scope shaw issue&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	var cwd string
     func init() {
         cwd, err := os.Getwd() //compile error: the &#39;cwd&#39; declared but not used
         if err != nil {
             log.Fatalf(&amp;quot;os.Getwd failed: %v&amp;quot;, err)
         }
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;cwd&amp;rsquo;, &amp;lsquo;err&amp;rsquo; are not declared in their block, so the compiler will declare them and will shadow the global &amp;lsquo;cwd&amp;rsquo; variable.&lt;/p&gt;

&lt;h2 id=&#34;section-3-basic-data-type&#34;&gt;Section 3, Basic Data Type&lt;/h2&gt;

&lt;h3 id=&#34;go-types&#34;&gt;Go types&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;basic types: numbers, strings, booleans&lt;/li&gt;
&lt;li&gt;aggregate types: arrays and structs&lt;/li&gt;
&lt;li&gt;reference types: slices, maps, functions, channels. (Each includes pointers that point to internal data)&lt;/li&gt;
&lt;li&gt;interface types&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;types-synonym&#34;&gt;Types synonym&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;int/uint types&amp;rsquo; size are platform and compiler dependent. &lt;strong&gt;&lt;em&gt;Never make assumption for the size!&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&amp;lsquo;rune&amp;rsquo; is synonym to &amp;lsquo;int32&amp;rsquo;, while &amp;lsquo;byte&amp;rsquo; to &amp;lsquo;uint8&amp;rsquo;&lt;/li&gt;
&lt;li&gt;&amp;lsquo;uintptr&amp;rsquo; is for the low level programming, like Go with C&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;operators&#34;&gt;Operators&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;the &amp;lsquo;%&amp;rsquo; for negative:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    fmt.Println(-5 % -2) //-1
    fmt.Println(5 % -2) //1
    fmt.Println(-5 % 2) //-1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;the result is &lt;strong&gt;&lt;em&gt;the same type as the operators&lt;/em&gt;&lt;/strong&gt;, so overflow may happen&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	var u uint8 = 255
    fmt.Println(u, u+1, u*u) // &amp;quot;255 0 1&amp;quot;
    var i int8 = 127
    fmt.Println(i, i+1, i*i) // &amp;quot;127 -128 1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;lsquo;unary operators&amp;rsquo;: &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;rsquo;, &amp;lsquo;^&amp;rsquo;&lt;/p&gt;

&lt;p&gt;** For integers, &amp;lsquo;+x&amp;rsquo; is short for &amp;lsquo;0 + x&amp;rsquo; while &amp;lsquo;-x&amp;rsquo; is short for &amp;lsquo;0 - x&amp;rsquo;
** For floating and complex numbers, &amp;lsquo;+x&amp;rsquo; is just for &amp;lsquo;x&amp;rsquo; while &amp;lsquo;-x&amp;rsquo; is the negative of &amp;lsquo;x&amp;rsquo;
** &amp;lsquo;^x&amp;rsquo; return the value with each bit inverted&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;NaN&amp;rsquo; is from like &amp;lsquo;0/0&amp;rsquo; or &amp;lsquo;sqrt(-1)&amp;rsquo;. Any comparation of &amp;lsquo;NaN&amp;rsquo; always yield false&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    nan := math.NaN()
    fmt.Println(nan == nan, nan &amp;lt; nan, nan &amp;gt; nan) // &amp;quot;false false false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Row string literal&lt;/em&gt;&lt;/strong&gt;: no escape happens and can cross multiple lines&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;conversion-and-format&#34;&gt;Conversion and format&lt;/h3&gt;

&lt;h4 id=&#34;printf&#34;&gt;Printf&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	o := 0666
	fmt.Printf(&amp;quot;%d %[1]o %#[1]o\n&amp;quot;, o) // &amp;quot;438 666 0666&amp;quot;
	x := int64(0xdeadbeef)
	fmt.Printf(&amp;quot;%d %[1]x %#[1]x %#[1]X\n&amp;quot;, x)
	// Output:
	// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &amp;lsquo;[1]&amp;rsquo; means use the first argument, so no need to provide the same argument again and again&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &amp;lsquo;#&amp;rsquo; is used to add the &amp;lsquo;0&amp;rsquo;, &amp;lsquo;0x&amp;rsquo;, &amp;lsquo;0X&amp;rsquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If space is after the &amp;lsquo;%&amp;rsquo;, like &amp;lsquo;% x&amp;rsquo;, then it will insert the space for each hex digits, like &amp;lsquo;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&amp;rsquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &amp;lsquo;strconv&amp;rsquo; package includes many format functions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &amp;lsquo;%t&amp;rsquo; show true or false, &amp;lsquo;%T&amp;rsquo; show the type&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;unicode&#34;&gt;Unicode&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Unicode version 8 use 4 bytes for each charactor, also knows as UTF-32/UCS-4. In Go, the &amp;lsquo;rune&amp;rsquo; is used for this.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unicode wasts lots of space, so the &amp;lsquo;UTF-8&amp;rsquo; is invented.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00xxxxxx runes0−127 (ASCII)
111xxxxx 10xxxxxx 128−2047 (values &amp;lt;128 unused)
1110xxxx 10xxxxxx 10xxxxxx 2048−65535 (values &amp;lt;2048 unused)
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536−0x10ffff (other values unused)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Code point&lt;/p&gt;

&lt;p&gt;Same values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;quot;世界&amp;quot;
&amp;quot;\xe4\xb8\x96\xe7\x95\x8c&amp;quot; //the binary using the UTF-8 coding
&amp;quot;\u4e16\u754c&amp;quot; //the binary using the Unicode, will be encoded as UTF-8 by the compiler
&amp;quot;\U00004e16\U0000754c&amp;quot; //the binary using the Unicode, will be encoded as UTF-8 by the compiler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They are all valid UTF-8 encoding of code point, but in Go, when for &amp;lsquo;rune&amp;rsquo;, value below 256 can used as &amp;lsquo;\x&amp;rsquo;, while above 256, must use &amp;lsquo;\u&amp;rsquo; or &amp;lsquo;\U&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;enumeratio&#34;&gt;enumeratio&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    _ = 1 &amp;lt;&amp;lt; (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776 (exceeds 1 &amp;lt;&amp;lt; 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424
    YiB // 1208925819614629174706176
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;lsquo;iota&amp;rsquo; is &amp;lsquo;int&amp;rsquo; type, so it will overflow.&lt;/p&gt;

&lt;h2 id=&#34;section-4-composite-types&#34;&gt;Section 4, Composite Types&lt;/h2&gt;

&lt;h3 id=&#34;about-array-type&#34;&gt;About array type&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The size is part of the type, so &amp;lsquo;[3]int&amp;rsquo; is different type from &amp;lsquo;[5]int&amp;rsquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Can init with specific indices&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;symbol := [...]string{0: &amp;quot;$&amp;quot;, 2: &amp;quot;9&amp;quot;, 5: &amp;quot;!&amp;quot;, 9: &amp;quot;&amp;quot;&amp;quot;}
r := [...]int{99: -1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the ones not in the indices will be init as the zero value.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arrays are comparable, &amp;lsquo;equal&amp;rsquo; when the two arrays have the same type and all the elements are the same&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;about-the-slice-type&#34;&gt;About the slice type&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Index beyonds the capcity will cause panic, while beyonds length will expend the slice&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;rsquo;s[i:j]&amp;rsquo; will share the same underlying array with slice &amp;rsquo;s&amp;rsquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slices are &lt;strong&gt;&lt;em&gt;not comparable&lt;/em&gt;&lt;/strong&gt;. For &amp;lsquo;[]byte], using the &amp;lsquo;bytes.Equal&amp;rsquo; to compare&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Nil slice has zero length and zero capcity, while the reverse is not right.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Nil slice and non-nil slice with zero length should be treated in the same way, so using &amp;lsquo;len(s) == 0&amp;rsquo; to check if a slice is empty&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Under the hood, &amp;lsquo;make&amp;rsquo; creates an unnamed array variable and returns a slice of it&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;With append, slice may enlarge its space to hold new elements. The copy will handle the overlap of the underlying array.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;about-the-map-type&#34;&gt;About the map type&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Lookup using a key not existing will return the zero value of the value type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := make(map[string]int)
a[&amp;quot;bob&amp;quot;] = a[&amp;quot;bob&amp;quot;] + 1
fmt.Println(a[&amp;quot;bob&amp;quot;]) //will output 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can use the &amp;lsquo;++&amp;rsquo; to increase the value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := make(map[string]int)
a[&amp;quot;bob&amp;quot;]++
fmt.Println(a[&amp;quot;bob&amp;quot;]) //will output 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A map element is not variable, you can never try to get its address. &lt;strong&gt;&lt;em&gt;But on the different, you can get the address of a slice element&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_ = &amp;amp;a[&amp;quot;bob&amp;quot;] //compile error
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Zero value of the map is nil.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ages map[string]int
fmt.Println(ages == nil)    // &amp;quot;true&amp;quot;
fmt.Println(len(ages) == 0) // &amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A nil map supprts operations: lookup, delete, len, range, but not &lt;strong&gt;&lt;em&gt;store value&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var aa map[string]int
aa[&amp;quot;bob&amp;quot;] = 100 //panic, the map must be created before storing any value
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The maps are not comparable except for comparision with nil.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;about-the-struct-type&#34;&gt;About the struct type&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Will compile error&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func create(id int) Employee {
//...
}
create(100).Name = &amp;quot;bob&amp;quot; //compile error, change the return type to *Employee will be ok
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fields not exported in a struct cannot be inited in another package&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package p
type T struct{ a, b int } // a and b are not exported

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package q
import &amp;quot;p&amp;quot;
var _ = p.T{a: 1, b: 2} // compile error: can&#39;t reference a, b
var _ = p.T{1, 2}       // compile error: can&#39;t reference a, b

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is also wrong:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package p
type T struct{ A, b, C int } // a and b are not exported

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package q
import &amp;quot;p&amp;quot;
var _ = p.T{1, 2}       // compile error: can&#39;t reference A, b
var _ = p.T{A: 1, C: 2} // ok
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Embedding will form an &lt;strong&gt;anoymous&lt;/strong&gt; field of the struct with the implicit field name of the embedded type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Point struct {
    X, Y int
}

type Circle struct {
    Point // form a anoymous field with implicit field name &amp;quot;Point&amp;quot;
    Radius int 
}

type Wheel struct {
    Circle // form a anoymous field with implicit field name &amp;quot;Circle&amp;quot;
    Spokes int 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you cannot embed the same type for more than twice, as their implicit names will conflict.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The implicit name can be optional for dot expression&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;w := new(Wheel)
w.Circle.Radius = 100
w.Radius = 100 // Both of the two are valid
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The embedded struct cannot init by normal struct literal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields
w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You must init like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;w = Wheel{Circle{Point{8, 8}, 5}, 20}
w = Wheel{
  Circle: Circle{
       Point:  Point{X: 8, Y: 8},
  Radius: 5,
  },
  Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)
}
fmt.Printf(&amp;quot;%#v\n&amp;quot;, w)
// Output:
// Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}
w.X = 42
fmt.Printf(&amp;quot;%#v\n&amp;quot;, w)
// Output:
// Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;about-the-json&#34;&gt;About the JSON&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;field tag&lt;/em&gt;&lt;/strong&gt; is a string of metadata associated at compile time with the field of a struct. It&amp;rsquo;s a &amp;lsquo;key:&amp;ldquo;value&amp;rdquo;&amp;rsquo; pair.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Year  int  `json:&amp;quot;released&amp;quot;`
Color bool `json:&amp;quot;color,omitempty&amp;quot;`
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The JSON field tag format: &lt;code&gt;json:&amp;quot;&amp;lt;json name&amp;gt;,[addition option]&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When Marshal, the not exported fields will be ignored; When Unmarshal, the fields of JSON that are not in the data struct will be ignored&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Associating JSON names with Go struct names during Unmarshaling is &lt;strong&gt;&lt;em&gt;case-insensitive&lt;/em&gt;&lt;/strong&gt;, so no need to add the JSON field tag for simple field name. But for the Marshal, you must define the JSON field tag, or the capital name will be used.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;section-4-functions&#34;&gt;Section 4, Functions&lt;/h2&gt;

&lt;h3 id=&#34;function-definition&#34;&gt;Function definition&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If return only one unamed type, the &amp;lsquo;()&amp;rsquo; can be omitted in the return result definition.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parameters and named results share the same level of the function outermost block.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go-function-stack&#34;&gt;Go function stack&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Go has a variable size function stack, so the recursive is always safe.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;about-the-defer&#34;&gt;About the defer&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &amp;lsquo;defer&amp;rsquo; forms a stack and wil be called by stack before the function return.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Even panic in the function, the &amp;lsquo;defer&amp;rsquo; will be called too.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;section-6-methods&#34;&gt;Section 6, Methods&lt;/h2&gt;

&lt;h3 id=&#34;about-the-receiver&#34;&gt;About the receiver&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The compiler will perform implicit &amp;lsquo;&amp;amp;p&amp;rsquo; on the variable when the receiver is the pointer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Point struct {
    x int
    y int
}

func (p *Point) Offset(off int) {
    p.x += off
    p.y += off
}

//...
p := Point{}
p.Offset(10) // This is valid, as the compiler will perform implicit &#39;&amp;amp;p&#39; on this.
Point{1, 2}.Offset(100) // compile error, as it&#39;s not the variable and cannot be addressed.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s true on these three scenarios:&lt;/p&gt;

&lt;p&gt;1) The type of the variable is the same as the receiver parameter
2) The type of the variable is T, while the receiver parameter is *T (The compiler will implicitly perform &amp;lsquo;&amp;amp;p&amp;rsquo;)
3) The type of the variable is *T, while the receiver parameter is T (The compiler will implicitly perform &amp;lsquo;*p&amp;rsquo;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bind the method with the receiver and assign to a variable, then you can call the method without the receiver via the variable. This is called &lt;strong&gt;&lt;em&gt;method value&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := Point{1, 2}
q := Point{4, 6}
distanceFromP := p.Distance
fmt.Println(distanceFromP(q))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assigning the method to variable directly is called &lt;strong&gt;&lt;em&gt;method expression&lt;/em&gt;&lt;/strong&gt;, you can then call it by providing the receiver as the first parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := Point{1, 2}
q := Point{4, 6}
distance := Point.Distance   // method expression
fmt.Println(distance(p, q))  // &amp;quot;5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;about-the-embedding&#34;&gt;About the embedding&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Embedding a type will inherit all its methods. In terms of implementation, the compiler will generate the wrapped methods with the type.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;about-the-encapsulation&#34;&gt;About the encapsulation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;All fields in the struct is visible to any function or any method in the same package&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;section-7-interfaces&#34;&gt;Section 7, Interfaces&lt;/h2&gt;

&lt;h3 id=&#34;about-the-interface-satisfaction&#34;&gt;About the interface satisfaction&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Though you can use the type T to access &lt;code&gt;*T&lt;/code&gt; method (the compiler will perform it implicitly), but you cannot use type T to satisfy the &lt;code&gt;*T&lt;/code&gt; type interface.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;interface-values&#34;&gt;interface values&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;An interface value is composed of: dynamic type and dynamic value. The type is the dynamic type of the value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var w io.Writer // both the type and value are nil
if w == nil { // this is true
    fmt.Println(&#39;is nil&#39;)
}

var buf *bytes.Buffer // buf is a nil pointer
w = nil // both the type and value are nil
w = buf // the type is &#39;*bytes.Buffer&#39; (not nil), while the value is nil
if w == nil { // this is false, as the type of w is not nil, so the w is not nil
    fmt.Println(&#39;is nil&#39;)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;interface value comparation may cause panic&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // panic: comparing uncomparable type []int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When comparation, both the type and value must be comparable. Similar risk eixsts when using the interfaces as the map keys.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To report the dynamic type of an interface value, using the &amp;lsquo;%T&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var w io.Writer
fmt.Printf(&amp;quot;%T\n&amp;quot;, w) // &amp;quot;&amp;lt;nil&amp;gt;&amp;quot;
w = os.Stdout
fmt.Printf(&amp;quot;%T\n&amp;quot;, w) // &amp;quot;*os.File&amp;quot;
w = new(bytes.Buffer)
fmt.Printf(&amp;quot;%T\n&amp;quot;, w) // &amp;quot;*bytes.Buffer&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;type-assertion&#34;&gt;Type assertion&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;x.(T), if T is a concrete type, it will check if x&amp;rsquo;s dynamic type is identical to T, if so the results is the dynamic value, or it will panic. If the T is a interface type, it will first check if x&amp;rsquo;s dynamic type satisfies T, if so, a new interface value will be returned with the new dynamic type T and the same dynamic value.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No matter what type was asserted, if the operand is a nil interface value, the type assertion fails&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;type-switch&#34;&gt;Type switch&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;take one example, you can assign the x.(type) to a new variable&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func sqlQuote(x interface{}) string {
         switch x := x.(type) {
         case nil:
             return &amp;quot;NULL&amp;quot;
         case int, uint:
             return fmt.Sprintf(&amp;quot;%d&amp;quot;, x) // x has type interface{} here.
         case bool:
             if x {
                 return &amp;quot;TRUE&amp;quot;
            }
             return &amp;quot;FALSE&amp;quot;
         case string:
             return sqlQuoteString(x) // (not shown)
         default:
            panic(fmt.Sprintf(&amp;quot;unexpected type %T: %v&amp;quot;,wxw,wx.i)t)-ebooks.info }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;section-8-goroutines-and-channels&#34;&gt;Section 8, Goroutines and Channels&lt;/h2&gt;

&lt;h3 id=&#34;channels&#34;&gt;Channels&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The channel is a reference.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;channels are comparable, it&amp;rsquo;s true when both are references to the same channel data structure.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A channel can be closed, send to a closed channel will cause panic, while receive on a closed channel, it will yield zero value of the channel element type after the channel is empty.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To test on a closed channel, use like &lt;code&gt;x, ok := &amp;lt;- c&lt;/code&gt;, to be comvinent, you can use the &amp;lsquo;range&amp;rsquo; to loop the channel until it&amp;rsquo;s drain and closed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for x := range naturals { // the loop will exit when the channel &#39;naturals&#39; is drained and closed.
    squares &amp;lt;- x * x
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s not necessary to close the channel when you finish with it. Only close it when you want to tell the receive that you will sent anymore data. It&amp;rsquo;s different from the file, you must always close a file after finishing with it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unidirectional channels: the &lt;code&gt;chan&amp;lt;- int&lt;/code&gt; is send-only channel, the &lt;code&gt;&amp;lt;-chan int&lt;/code&gt; is the receive-only channel. And the &lt;code&gt;close&lt;/code&gt; must not be applied on the receive-only channel. It will implicitly convert &lt;code&gt;chan int&lt;/code&gt; to &lt;code&gt;chan&amp;lt;- int&lt;/code&gt; and &lt;code&gt;&amp;lt;-chan int&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To get the capcity of the channel, using the &lt;code&gt;cap(c)&lt;/code&gt;, while the &lt;code&gt;len(c)&lt;/code&gt; returns the currently number of the buffered elements.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An typical example for loop paralle&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func makeThumbnails6(filenames &amp;lt;-chan string) int64 {
         sizes := make(chan int64)
         var wg sync.WaitGroup // number of working goroutines
         for f := range filenames {
             wg.Add(1)
             // worker
             go func(f string) {
                 defer wg.Done()
                 thumb, err := thumbnail.ImageFile(f)
                 if err != nil {
                     log.Println(err)
                         return
                         }
                 info, _ := os.Stat(thumb) // OK to ignore error
                 sizes &amp;lt;- info.Size()
             }(f)
         }
         // closer
         go func() {
             wg.Wait()
             close(sizes)
         }()
         var total int64
         for size := range sizes {
             total += size
         }
         return total
     }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using a buffered channel as a semaphore&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var sema = make(chan struct{}, 10)
func dowork() {
    sema &amp;lt;- struct{}{} // acquire the sema
    defer func() { &amp;lt;-sema }() // release the sema
    // do something here
    //...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using select with a closeable channel to cancel the goroutines. Closing the channel is like broadcasting the goroutines to let them exit gracefully.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    done := make(chan struct{})
    jc := make(chan string)
    go func() {
        select {
        case &amp;lt;-done:
            return
        case job := &amp;lt;-jc:
            //do something with the job
        }
    }()

    jc&amp;lt;- &amp;quot;hello&amp;quot;
    close(done)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;section-9-concurrency-with-shared-variables&#34;&gt;Section 9, Concurrency with Shared Variables&lt;/h2&gt;

&lt;h3 id=&#34;mutex&#34;&gt;Mutex&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;defer will be be executed even the func panic&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The mutex is not &lt;strong&gt;&lt;em&gt;re-entrant&lt;/em&gt;&lt;/strong&gt;, which means that it can not be locked recursively.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Different goroutines may run on different CPU, different statements may be reordered by the modern compiler and CPU when they are not dependent on each other.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;     var x, y int
     go func() {
         x = 1 // A1
         fmt.Print(&amp;quot;y:&amp;quot;, y, &amp;quot; &amp;quot;) // A2
     }()
     go func() {
         y = 1                   // B1
         fmt.Print(&amp;quot;x:&amp;quot;, x, &amp;quot; &amp;quot;) // B2
     }()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result may be &amp;ldquo;x = 0, y = 0&amp;rdquo;, as the CPU or compiler may reorder the statements; the different goroutines may run on different CPU, and the update may happen on each CPU cache and doesn&amp;rsquo;t sync with main memory on time. The mutex will make sure the right order.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Duplicate suppression&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type entry struct {
         res   result
         ready chan struct{} // closed when res is ready
     }

func New(f Func) *Memo {
     return &amp;amp;Memo{f: f, cache: make(map[string]*entry)}
}

type Memo struct {
    f     Func
    mu    sync.Mutex // guards cache
    cache map[string]*entry
}

func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    e := memo.cache[key]
    if e == nil {
        // This is the first request for this key.
        // This goroutine becomes responsible for computing
        // the value and broadcasting the ready condition.
        e = &amp;amp;entry{ready: make(chan struct{})}
        memo.cache[key] = e
        memo.mu.Unlock()
        e.res.value, e.res.err = memo.f(key)
        close(e.ready) // broadcast ready condition
    } else {
        // This is a repeat request for this key.
        memo.mu.Unlock()
        &amp;lt;-e.ready // wait for ready condition
    }
    return e.res.value, e.res.err
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;goroutines-vs-os-threads&#34;&gt;Goroutines vs OS threads&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Goroutine has dynamic size of stack, which is up to 1GB while the OS thread is typical 2MB.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Goroutines schedule implicitly by certain Go language constructs, like time.Sleep, channel block, mutex block, etc, no need to switch kernel context. While the OS threads schedule is invoked every few ms, need to switch kernel context.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GOMAXPROCS is the default the number of the CPU on the machine.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;section-10-packages-and-the-go-tool&#34;&gt;Section 10, Packages and The Go Tool&lt;/h2&gt;

&lt;h3 id=&#34;go-build&#34;&gt;Go build&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Using flag &amp;lsquo;-u&amp;rsquo; in &amp;lsquo;go get&amp;rsquo; will update the current repo to the latest version.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &amp;lsquo;go build -i&amp;rsquo; will install the dependent packages and will decrease the compile time next time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cross compile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ GOARCH=386 go build -i gopl.io/ch10/cross // it will install in $GOPATH/pkg/386
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Files like &lt;code&gt;net_linux.go&lt;/code&gt; or &lt;code&gt;asm_amd64.s&lt;/code&gt;, the compiler will compile it based on the env.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Comment &lt;em&gt;before&lt;/em&gt; the file package declaration can also control the compiling. &lt;code&gt;// +build linux darwin&lt;/code&gt; means only compile it for linux and darwin, &lt;code&gt;// +build ignore&lt;/code&gt; means never compile this file.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go-doc&#34;&gt;Go doc&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The first sentence is usually a summary that starts with the declared name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Fprintf formats according to a format specifier and writes to w.
// It returns the number of bytes written and any write error encountered.
func Fprintf(w io.Writer, format string, a ...interface{}) (int, error)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check the doc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go doc json.encode
func (dec *Decoder) Decode(v interface{}) error
    Decode reads the next JSON-encoded value from its input and stores
    it in the value pointed to by v.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Export the doc to html and serve it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ godoc -http :8000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then, access the doc via &lt;a href=&#34;http://localhost:8000/pkg&#34;&gt;http://localhost:8000/pkg&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;internal-packages&#34;&gt;Internal packages&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;package under the &amp;lsquo;internal&amp;rsquo; directory is the internal package&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Can be seen by the packages under the parent of the &amp;lsquo;internal&amp;rsquo; directory&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net/http
net/http/internal/chunked
net/http/httputil
net/url
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;lsquo;net/http/internal/chunked&amp;rsquo; can be seen by &amp;lsquo;net/http&amp;rsquo;, &amp;lsquo;net/http/httputil&amp;rsquo;, while not seen by &amp;lsquo;net/url&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go-list&#34;&gt;Go list&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;list the packages&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List all the packages under the workspace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go list ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List all under path&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go list gopl.io/ch3/...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List by matched pattern&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go list ...xml...
encoding/xml
gopl.io/ch7/xmlselect
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;go list -json&lt;/code&gt; to show by json format of the package detail info.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go list -json hash
{
    &amp;quot;Dir&amp;quot;: &amp;quot;/home/gopher/go/src/hash&amp;quot;,
        &amp;quot;ImportPath&amp;quot;: &amp;quot;hash&amp;quot;,
        &amp;quot;Name&amp;quot;: &amp;quot;hash&amp;quot;,
        &amp;quot;Doc&amp;quot;: &amp;quot;Package hash provides interfaces for hash functions.&amp;quot;,
        &amp;quot;Target&amp;quot;: &amp;quot;/home/gopher/go/pkg/darwin_amd64/hash.a&amp;quot;,
        &amp;quot;Goroot&amp;quot;: true,
        &amp;quot;Standard&amp;quot;: true,
        &amp;quot;Root&amp;quot;: &amp;quot;/home/gopher/go&amp;quot;,
        &amp;quot;GoFiles&amp;quot;: [
            &amp;quot;hash.go&amp;quot; ],
            &amp;quot;Imports&amp;quot;: [
                &amp;quot;io&amp;quot;
            ],
            &amp;quot;Deps&amp;quot;: [
                &amp;quot;errors&amp;quot;,
            &amp;quot;io&amp;quot;,
            &amp;quot;runtime&amp;quot;,
            &amp;quot;sync&amp;quot;,
            &amp;quot;sync/atomic&amp;quot;,
            &amp;quot;unsafe&amp;quot;
            ] 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;rsquo;-f &amp;lsquo; to customize the output format&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go list -f &#39;{{join .Deps &amp;quot; &amp;quot;}}&#39; strconv
 errors math runtime unicode/utf8 unsafe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It lists all the dependencies. Actually, the &amp;lsquo;-f&amp;rsquo; is like using the text template to format the output.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;section-11-testing&#34;&gt;Section 11, Testing&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Within &lt;code&gt;*_test.go&lt;/code&gt; files, three kinds of functions are treated specially : tests, benchmarks, and examples. Function starts with &amp;lsquo;Test&amp;rsquo; is for tests, &amp;lsquo;Benchmark&amp;rsquo; is for benchmarks, &amp;lsquo;Example&amp;rsquo; is for examples.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tests&#34;&gt;Tests&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;rsquo;-run&amp;rsquo; to run specific cases using the regular expression&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -v -run=&amp;quot;French|Canal&amp;quot;
     === RUN TestFrenchPalindrome
     --- FAIL: TestFrenchPalindrome (0.00s)
         word_test.go:28: IsPalindrome(&amp;quot;été&amp;quot;) = false
     === RUN TestCanalPalindrome
     --- FAIL: TestCanalPalindrome (0.00s)
         word_test.go:35: IsPalindrome(&amp;quot;A man, a plan, a canal: Panama&amp;quot;) = false
     FAIL
     exit status 1
     FAIL    gopl.io/ch11/word1  0.014s
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;external-test-package&#34;&gt;External Test Package&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sometimes, in case of a cycle of dependencies in test files, use the &lt;code&gt;_test&lt;/code&gt; to declare a external test package. For example, in &amp;lsquo;net/url&amp;rsquo;, the test file may declare package like &lt;code&gt;package url_test&lt;/code&gt;, the compiler will create an external package for this implicitly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go list -f={{.GoFiles}} fmt
     [doc.go format.go print.go scan.go]
$ go list -f={{.TestGoFiles}} fmt
     [export_test.go]
$ go list -f={{.XTestGoFiles}} fmt
     [fmt_test.go scan_test.go stringer_test.go]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;lsquo;XTestGoFiles&amp;rsquo; is the external test package files.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In external package test file, you cannot access the private variable or functions in the tested package. In order to do while-box testing in external package test files, using a export file to export the private things. And this file is always called &lt;code&gt;export_test.go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For example, the &lt;code&gt;export_test.go&lt;/code&gt; file for the &amp;lsquo;fmt&amp;rsquo; package is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package fmt
var IsSpace = isSpace
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;benchmark-testing&#34;&gt;Benchmark Testing&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Test and check the memory&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -bench=. -benchmem
     PASS
          BenchmarkIsPalindrome    2000000    807 ns/op  128 B/op  1 allocs/op
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;profiling&#34;&gt;Profiling&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Profiling when testing&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -cpuprofile=cpu.out
$ go test -blockprofile=block.out
$ go test -memprofile=mem.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then run the pprof tool&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ go test -run=NONE -bench=ClientServerParallelTLS64 \
             -cpuprofile=cpu.log net/http
     PASS
     BenchmarkClientServerParallelTLS64-8  1000
        3141325 ns/op  143010 B/op  1747 allocs/op
     ok      net/http       3.395s
     $ go tool pprof -text -nodecount=10 ./http.test cpu.log
     2570ms of 3590ms total (71.59%)
     Dropped 129 nodes (cum &amp;lt;= 17.95ms)
     Showing top 10 nodes out of 166 (cum &amp;gt;= 60ms)
         flat  flat%   sum%     cum   cum%
       1730ms 48.19% 48.19%  1750ms 48.75%  crypto/elliptic.p256ReduceDegree
        230ms  6.41% 54.60%   250ms  6.96%  crypto/elliptic.p256Diff
        120ms  3.34% 57.94%   120ms  3.34%  math/big.addMulVVW
        110ms  3.06% 61.00%   110ms  3.06%  syscall.Syscall
         90ms  2.51% 63.51%  1130ms 31.48%  crypto/elliptic.p256Square
         70ms  1.95% 65.46%   120ms  3.34%  runtime.scanobject
         60ms  1.67% 67.13%   830ms 23.12%  crypto/elliptic.p256Mul
         60ms  1.67% 68.80%   190ms  5.29%  math/big.nat.montgomery
         50ms  1.39% 70.19%    50ms  1.39%  crypto/elliptic.p256ReduceCarry
         50ms  1.39% 71.59%    60ms  1.67%  crypto/elliptic.p256Sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-nodecount=10&lt;/code&gt; means showing only 10 rows&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-testing&#34;&gt;Example Testing&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;For example test &lt;code&gt;ExampleFuncName&lt;/code&gt;, the &lt;code&gt;go doc&lt;/code&gt; will add this example to the function &lt;code&gt;FuncName&lt;/code&gt; automatically.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;section-12-reflection&#34;&gt;Section 12, Reflection&lt;/h2&gt;

&lt;h3 id=&#34;reflect-type-and-value&#34;&gt;reflect, type and value&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;reflect.TypeOf&lt;/code&gt; return the dynamic type of the interface value. The &amp;lsquo;%T&amp;rsquo; in &lt;code&gt;fmt&lt;/code&gt; is using this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var w io.Writer = os.Stdout
fmt.Println(reflect.TypeOf(w)) // &amp;quot;*os.File&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;reflect.ValueOf&lt;/code&gt; to get the value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;v := reflect.ValueOf(3) // a reflect.Value
fmt.Println(v)          // &amp;quot;3&amp;quot;
fmt.Printf(&amp;quot;%v\n&amp;quot;, v)   // &amp;quot;3&amp;quot;
fmt.Println(v.String()) // NOTE: &amp;quot;&amp;lt;int Value&amp;gt;&amp;quot;
t := v.Type() // a reflect.Type
fmt.Println(t.String()) // &amp;quot;int&amp;quot;
v := reflect.ValueOf(3) // a reflect.Value
x := v.Interface() // an interface{}
i := x.(int) // an int 
fmt.Printf(&amp;quot;%d\n&amp;quot;, i) // &amp;quot;3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;reflect.Value.Kind&lt;/code&gt; usage. Kind of zero value is &lt;code&gt;reflect.Invalid&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func formatAtom(v reflect.Value) string {
         switch v.Kind() {
         case reflect.Invalid:
             return &amp;quot;invalid&amp;quot;
         case reflect.Int, reflect.Int8, reflect.Int16,
             reflect.Int32, reflect.Int64:
             return strconv.FormatInt(v.Int(), 10)
         case reflect.Uint, reflect.Uint8, reflect.Uint16,
             reflect.Uint32, reflect.Uint64, reflect.Uintptr:
             return strconv.FormatUint(v.Uint(), 10)
         // ...floating-point and complex cases omitted for brevity...
         case reflect.Bool:
             return strconv.FormatBool(v.Bool())
         case reflect.String:
             return strconv.Quote(v.String())
         case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:
             return v.Type().String() + &amp;quot; 0x&amp;quot; +
                 strconv.FormatUint(uint64(v.Pointer()), 16)
         default: // reflect.Array, reflect.Struct, reflect.Interface
             return v.Type().String() + &amp;quot; value&amp;quot;
} }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;reflect for the Composite Types&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func display(path string, v reflect.Value) {
         switch v.Kind() {
         case reflect.Invalid:
             fmt.Printf(&amp;quot;%s = invalid\n&amp;quot;, path)
         case reflect.Slice, reflect.Array:
             for i := 0; i &amp;lt; v.Len(); i++ {
                 display(fmt.Sprintf(&amp;quot;%s[%d]&amp;quot;, path, i), v.Index(i))
             }
         case reflect.Struct:
             for i := 0; i &amp;lt; v.NumField(); i++ {
                 fieldPath := fmt.Sprintf(&amp;quot;%s.%s&amp;quot;, path, v.Type().Field(i).Name)
                 display(fieldPath, v.Field(i))
             }
         case reflect.Map:
             for _, key := range v.MapKeys() {
                 display(fmt.Sprintf(&amp;quot;%s[%s]&amp;quot;, path,
                     formatAtom(key)), v.MapIndex(key))
             }
         case reflect.Ptr:
             if v.IsNil() {
                 fmt.Printf(&amp;quot;%s = nil\n&amp;quot;, path)
             } else {
                 display(fmt.Sprintf(&amp;quot;(*%s)&amp;quot;, path), v.Elem())
             }
         case reflect.Interface:
             if v.IsNil() {
                 fmt.Printf(&amp;quot;%s = nil\n&amp;quot;, path)
             } else {
                 fmt.Printf(&amp;quot;%s.type = %s\n&amp;quot;, path, v.Elem().Type())
                 display(path+&amp;quot;.value&amp;quot;, v.Elem())
             }
         default: // basic types, channels, funcs
             fmt.Printf(&amp;quot;%s = %s\n&amp;quot;, path, formatAtom(v))
         }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x := 1
rx := reflect.ValueOf(&amp;amp;x).Elem()
rx.SetInt(2) // OK, x = 2
rx.Set(reflect.ValueOf(3)) // OK, x = 3
rx.SetString(&amp;quot;hello&amp;quot;) // panic: string is not assignable to int
rx.Set(reflect.ValueOf(&amp;quot;hello&amp;quot;)) // panic: string is not assignable to int
var y interface{}
ry := reflect.ValueOf(&amp;amp;y).Elem()
ry.SetInt(2) // panic: SetInt called on interface Value
ry.Set(reflect.ValueOf(3)) // OK, y = int(3)
ry.SetString(&amp;quot;hello&amp;quot;) // panic: SetString called on interface Value
ry.Set(reflect.ValueOf(&amp;quot;hello&amp;quot;)) // OK, y = &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can use reflect to access the unexport fields of a struct, but you cannot update it, because the reflect will records whether it&amp;rsquo;s exported or not.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;stdout := reflect.ValueOf(os.Stdout).Elem() // *os.Stdout, an os.File var
fmt.Println(stdout.Type())                  // &amp;quot;os.File&amp;quot;
fd := stdout.FieldByName(&amp;quot;fd&amp;quot;)
fmt.Println(fd.Int()) // &amp;quot;1&amp;quot;
fd.SetInt(2)          // panic: unexported field
fmt.Println(fd.CanAddr(), fd.CanSet()) // &amp;quot;true false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;access the struct tags&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Build map of fields keyed by effective name.
    fields := make(map[string]reflect.Value)
    v := reflect.ValueOf(ptr).Elem() // the struct variable
    for i := 0; i &amp;lt; v.NumField(); i++ {
        fieldInfo := v.Type().Field(i) // a reflect.StructField
        tag := fieldInfo.Tag           // a reflect.StructTag
        name := tag.Get(&amp;quot;http&amp;quot;)
        if name == &amp;quot;&amp;quot; {
            name = strings.ToLower(fieldInfo.Name)
        }
        fields[name] = v.Field(i)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;access the methods. Using &lt;code&gt;reflect.Value.Call&lt;/code&gt; is possible to call the method&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Print prints the method set of the value x.
 func Print(x interface{}) {
     v := reflect.ValueOf(x)
     t := v.Type()
     fmt.Printf(&amp;quot;type %s\n&amp;quot;, t)
     for i := 0; i &amp;lt; v.NumMethod(); i++ {
         methType := v.Method(i).Type()
         fmt.Printf(&amp;quot;func (%s) %s%s\n&amp;quot;, t, t.Method(i).Name,
             strings.TrimPrefix(methType.String(), &amp;quot;func&amp;quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Reflect is fragile and will cause terrible performance issue is it&amp;rsquo;s in the critical code path.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>